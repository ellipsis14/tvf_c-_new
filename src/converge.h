// This code conforms with the UFC specification version 2017.2.0
// and was automatically generated by FFC version 2017.2.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              None
//  quadrature_rule:                None
//  representation:                 'auto'
//  split:                          False

#ifndef __CONVERGE_H
#define __CONVERGE_H
#include <algorithm>
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <ufc.h>

class converge_finite_element_0: public ufc::finite_element
{
public:

  converge_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  ~converge_finite_element_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Lagrange', triangle, 1)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 3;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 3 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[3] = {};
    const std::size_t num_components[3] = { 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 3; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 3 * num_derivatives, 0.0);
    const std::size_t reference_offsets[3] = {};
    const std::size_t physical_offsets[3] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 3; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[3 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[3 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[3];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[3];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 3, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 6, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new converge_finite_element_0();
  }

};


class converge_finite_element_1: public ufc::finite_element
{
public:

  converge_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  ~converge_finite_element_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 6;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 2;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 2;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 6 * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 6 * num_derivatives * 2, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t num_components[6] = { 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 6; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 6 * num_derivatives * 2, 0.0);
    const std::size_t reference_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t physical_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 6; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[12];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[12];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 2; ++k)
        values[k] = physical_values[2 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2; ++s)
            values[r * 2 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 2 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 2 * num_derivatives * 6, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2 * num_derivatives; ++s)
            values[2 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[3] = dof_values[4];
    vertex_values[5] = dof_values[5];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[12] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 2;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new converge_finite_element_0();
    case 1:
        return new converge_finite_element_0();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new converge_finite_element_1();
  }

};


class converge_finite_element_2: public ufc::finite_element
{
public:

  converge_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  ~converge_finite_element_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Discontinuous Lagrange', triangle, 4)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 15;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 4;
  }

  const char * family() const final override
  {
    return "Discontinuous Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][15] = { { 0.0, -0.04123930494211609, -0.023809523809523822, 0.028980029497627822, 0.022447834323382442, 0.012960263189328967, -0.03959425806109992, -0.03346325566315744, -0.02592052637865797, -0.014965222882254974, 0.03212472543663117, 0.028331344813852292, 0.023944356611607955, 0.01854721887848184, 0.0107082418122104 } };
    static const double coefficients1[1][15] = { { 0.0, 0.04123930494211613, -0.023809523809523784, 0.02898002949762785, -0.022447834323382466, 0.012960263189328984, 0.0395942580610999, -0.03346325566315744, 0.02592052637865797, -0.014965222882254966, 0.03212472543663116, -0.0283313448138523, 0.02394435661160794, -0.01854721887848182, 0.01070824181221038 } };
    static const double coefficients2[1][15] = { { 0.0, 0.0, 0.04761904761904767, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.059860891529019876, 0.0, 0.0, 0.0, 0.0, 0.05354120906105191 } };
    static const double coefficients3[1][15] = { { 0.12570787221094168, 0.13196577581477154, -0.025396825396825307, 0.13910414158861364, -0.07183306983482386, 0.031104631654389595, 0.06335081289775987, 0.026770604530525932, -0.0622092633087791, 0.047888713223215876, 0.0, 0.056662689627704585, -0.08380524814062787, 0.08346248495316817, -0.05354120906105193 } };
    static const double coefficients4[1][15] = { { -0.03142696805273548, 0.010997147984564424, 0.006349206349206469, 0.0, 0.1885618083164127, -0.16329931618554513, 0.0, 0.09369711585684087, 0.0, -0.04190262407031398, 0.0, 0.0, 0.08380524814062781, -0.13910414158861362, 0.10708241812210383 } };
    static const double coefficients5[1][15] = { { 0.12570787221094168, 0.0439885919382572, 0.12698412698412692, 0.0, 0.03591653491741195, 0.1555231582719478, 0.0, 0.0, 0.1036821055146319, -0.01197217830580397, 0.0, 0.0, 0.0, 0.09273609439240908, -0.10708241812210383 } };
    static const double coefficients6[1][15] = { { 0.12570787221094185, -0.13196577581477167, -0.025396825396825397, 0.13910414158861367, 0.07183306983482388, 0.031104631654389547, -0.06335081289775983, 0.02677060453052595, 0.062209263308779184, 0.04788871322321592, 0.0, -0.05666268962770455, -0.08380524814062786, -0.08346248495316819, -0.05354120906105191 } };
    static const double coefficients7[1][15] = { { -0.0314269680527354, -0.010997147984564262, 0.006349206349206462, 0.0, -0.18856180831641273, -0.16329931618554513, 0.0, 0.09369711585684086, 0.0, -0.041902624070313955, 0.0, 0.0, 0.08380524814062786, 0.13910414158861364, 0.1070824181221038 } };
    static const double coefficients8[1][15] = { { 0.12570787221094185, -0.04398859193825722, 0.12698412698412698, 0.0, -0.03591653491741193, 0.15552315827194774, 0.0, 0.0, -0.1036821055146319, -0.01197217830580399, 0.0, 0.0, 0.0, -0.09273609439240911, -0.1070824181221038 } };
    static const double coefficients9[1][15] = { { 0.12570787221094204, -0.08797718387651439, -0.10158730158730161, 0.09273609439240908, 0.10774960475223586, 0.07257747386024233, 0.0791885161221998, -0.01338530226526298, -0.05184105275731595, -0.041902624070313935, -0.12849890174652465, -0.0566626896277046, -0.011972178305803964, 0.009273609439240882, 0.010708241812210384 } };
    static const double coefficients10[1][15] = { { -0.03142696805273535, 0.0, -0.012698412698412615, -0.24343224778007383, 0.0, 0.05443310539518173, 0.0, 0.09369711585684086, 0.0, -0.041902624070313955, 0.19274835261978693, 0.0, -0.02394435661160798, 0.0, 0.010708241812210403 } };
    static const double coefficients11[1][15] = { { 0.12570787221094196, 0.08797718387651435, -0.10158730158730156, 0.09273609439240904, -0.10774960475223587, 0.07257747386024228, -0.07918851612219983, -0.013385302265262985, 0.05184105275731593, -0.041902624070313914, -0.1284989017465246, 0.05666268962770457, -0.011972178305803974, -0.009273609439240903, 0.010708241812210383 } };
    static const double coefficients12[1][15] = { { 0.25141574442188375, -0.35190873550605756, -0.20317460317460326, -0.13910414158861362, -0.10774960475223579, -0.062209263308779135, 0.19005243869327954, -0.02677060453052593, 0.12441852661755824, 0.15563831797545175, 0.0, 0.16998806888311374, 0.08380524814062784, -0.027820828317722715, -0.05354120906105193 } };
    static const double coefficients13[1][15] = { { 0.2514157444218835, 0.35190873550605745, -0.20317460317460317, -0.13910414158861362, 0.10774960475223574, -0.062209263308779184, -0.19005243869327954, -0.02677060453052594, -0.1244185266175582, 0.15563831797545172, 0.0, -0.16998806888311374, 0.08380524814062784, 0.027820828317722708, -0.0535412090610519 } };
    static const double coefficients14[1][15] = { { 0.2514157444218835, 0.0, 0.4063492063492063, 0.0, 0.0, -0.18662778992633738, 0.0, -0.18739423171368175, 0.0, -0.2035270311986676, 0.0, 0.0, -0.16761049628125566, 0.0, 0.10708241812210383 } };
    for (std::size_t k = 0; k < num_points * 15; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues4[15] = {};
        basisvalues4[0] = 1.0;
        const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues4[1] = tmp1_4;
        const double tmp2_4 = (1.0 - Y[1]) / 2.0;
        const double tmp3_4 = tmp2_4 * tmp2_4;
        basisvalues4[3] = 1.5 * tmp1_4 * basisvalues4[1] - 0.5 * tmp3_4 * basisvalues4[0];
        basisvalues4[6] = 1.6666666666666667 * tmp1_4 * basisvalues4[3] - 0.6666666666666666 * tmp3_4 * basisvalues4[1];
        basisvalues4[10] = 1.75 * tmp1_4 * basisvalues4[6] - 0.75 * tmp3_4 * basisvalues4[3];
        basisvalues4[2] = (0.5 + 1.5 * Y[1]) * basisvalues4[0];
        basisvalues4[4] = (1.5 + 2.5 * Y[1]) * basisvalues4[1];
        basisvalues4[7] = (2.5 + 3.5 * Y[1]) * basisvalues4[3];
        basisvalues4[11] = (3.5 + 4.5 * Y[1]) * basisvalues4[6];
        basisvalues4[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues4[2] - 0.5555555555555556 * basisvalues4[0];
        basisvalues4[9] = (0.05 + 1.75 * Y[1]) * basisvalues4[5] - 0.7 * basisvalues4[2];
        basisvalues4[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues4[9] - 0.7714285714285715 * basisvalues4[5];
        basisvalues4[8] = (0.54 + 2.1 * Y[1]) * basisvalues4[4] - 0.56 * basisvalues4[1];
        basisvalues4[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues4[8] - 0.7142857142857143 * basisvalues4[4];
        basisvalues4[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues4[7] - 0.5510204081632653 * basisvalues4[3];
        basisvalues4[0] *= std::sqrt(0.5);
        basisvalues4[2] *= std::sqrt(1.0);
        basisvalues4[5] *= std::sqrt(1.5);
        basisvalues4[9] *= std::sqrt(2.0);
        basisvalues4[14] *= std::sqrt(2.5);
        basisvalues4[1] *= std::sqrt(3.0);
        basisvalues4[4] *= std::sqrt(4.5);
        basisvalues4[8] *= std::sqrt(6.0);
        basisvalues4[13] *= std::sqrt(7.5);
        basisvalues4[3] *= std::sqrt(7.5);
        basisvalues4[7] *= std::sqrt(10.0);
        basisvalues4[12] *= std::sqrt(12.5);
        basisvalues4[6] *= std::sqrt(14.0);
        basisvalues4[11] *= std::sqrt(17.5);
        basisvalues4[10] *= std::sqrt(22.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip] += coefficients0[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 1] += coefficients1[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 2] += coefficients2[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 3] += coefficients3[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 4] += coefficients4[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 5] += coefficients5[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 6] += coefficients6[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 7] += coefficients7[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 8] += coefficients8[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 9] += coefficients9[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 10] += coefficients10[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 11] += coefficients11[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 12] += coefficients12[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 13] += coefficients13[0][r] * basisvalues4[r];
        for (std::size_t r = 0; r < 15; ++r)
            reference_values[15 * ip + 14] += coefficients14[0][r] * basisvalues4[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 15 * num_derivatives, 0.0);
    if (order > 4)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][15][15] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.29150262212921, 0.0, -2.9933259094191693, 13.662601021279473, 0.0, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 10.954451150103306, 0.0, 0.0, -3.8332593899996485, 0.0, 17.74823934929884, 0.0, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.732863826479687, 0.0, 3.3466401061362907, 4.364357804719845, 0.0, -5.074680379332367, 0.0, 17.008401285415214, 0.0, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 2.4494897427831663, 0.0, 0.0, 9.142857142857078, 0.0, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][15] = { { 0.0, -0.04123930494211609, -0.023809523809523822, 0.028980029497627822, 0.022447834323382442, 0.012960263189328967, -0.03959425806109992, -0.03346325566315744, -0.02592052637865797, -0.014965222882254974, 0.03212472543663117, 0.028331344813852292, 0.023944356611607955, 0.01854721887848184, 0.0107082418122104 } };
    static const double coefficients1[1][15] = { { 0.0, 0.04123930494211613, -0.023809523809523784, 0.02898002949762785, -0.022447834323382466, 0.012960263189328984, 0.0395942580610999, -0.03346325566315744, 0.02592052637865797, -0.014965222882254966, 0.03212472543663116, -0.0283313448138523, 0.02394435661160794, -0.01854721887848182, 0.01070824181221038 } };
    static const double coefficients2[1][15] = { { 0.0, 0.0, 0.04761904761904767, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.059860891529019876, 0.0, 0.0, 0.0, 0.0, 0.05354120906105191 } };
    static const double coefficients3[1][15] = { { 0.12570787221094168, 0.13196577581477154, -0.025396825396825307, 0.13910414158861364, -0.07183306983482386, 0.031104631654389595, 0.06335081289775987, 0.026770604530525932, -0.0622092633087791, 0.047888713223215876, 0.0, 0.056662689627704585, -0.08380524814062787, 0.08346248495316817, -0.05354120906105193 } };
    static const double coefficients4[1][15] = { { -0.03142696805273548, 0.010997147984564424, 0.006349206349206469, 0.0, 0.1885618083164127, -0.16329931618554513, 0.0, 0.09369711585684087, 0.0, -0.04190262407031398, 0.0, 0.0, 0.08380524814062781, -0.13910414158861362, 0.10708241812210383 } };
    static const double coefficients5[1][15] = { { 0.12570787221094168, 0.0439885919382572, 0.12698412698412692, 0.0, 0.03591653491741195, 0.1555231582719478, 0.0, 0.0, 0.1036821055146319, -0.01197217830580397, 0.0, 0.0, 0.0, 0.09273609439240908, -0.10708241812210383 } };
    static const double coefficients6[1][15] = { { 0.12570787221094185, -0.13196577581477167, -0.025396825396825397, 0.13910414158861367, 0.07183306983482388, 0.031104631654389547, -0.06335081289775983, 0.02677060453052595, 0.062209263308779184, 0.04788871322321592, 0.0, -0.05666268962770455, -0.08380524814062786, -0.08346248495316819, -0.05354120906105191 } };
    static const double coefficients7[1][15] = { { -0.0314269680527354, -0.010997147984564262, 0.006349206349206462, 0.0, -0.18856180831641273, -0.16329931618554513, 0.0, 0.09369711585684086, 0.0, -0.041902624070313955, 0.0, 0.0, 0.08380524814062786, 0.13910414158861364, 0.1070824181221038 } };
    static const double coefficients8[1][15] = { { 0.12570787221094185, -0.04398859193825722, 0.12698412698412698, 0.0, -0.03591653491741193, 0.15552315827194774, 0.0, 0.0, -0.1036821055146319, -0.01197217830580399, 0.0, 0.0, 0.0, -0.09273609439240911, -0.1070824181221038 } };
    static const double coefficients9[1][15] = { { 0.12570787221094204, -0.08797718387651439, -0.10158730158730161, 0.09273609439240908, 0.10774960475223586, 0.07257747386024233, 0.0791885161221998, -0.01338530226526298, -0.05184105275731595, -0.041902624070313935, -0.12849890174652465, -0.0566626896277046, -0.011972178305803964, 0.009273609439240882, 0.010708241812210384 } };
    static const double coefficients10[1][15] = { { -0.03142696805273535, 0.0, -0.012698412698412615, -0.24343224778007383, 0.0, 0.05443310539518173, 0.0, 0.09369711585684086, 0.0, -0.041902624070313955, 0.19274835261978693, 0.0, -0.02394435661160798, 0.0, 0.010708241812210403 } };
    static const double coefficients11[1][15] = { { 0.12570787221094196, 0.08797718387651435, -0.10158730158730156, 0.09273609439240904, -0.10774960475223587, 0.07257747386024228, -0.07918851612219983, -0.013385302265262985, 0.05184105275731593, -0.041902624070313914, -0.1284989017465246, 0.05666268962770457, -0.011972178305803974, -0.009273609439240903, 0.010708241812210383 } };
    static const double coefficients12[1][15] = { { 0.25141574442188375, -0.35190873550605756, -0.20317460317460326, -0.13910414158861362, -0.10774960475223579, -0.062209263308779135, 0.19005243869327954, -0.02677060453052593, 0.12441852661755824, 0.15563831797545175, 0.0, 0.16998806888311374, 0.08380524814062784, -0.027820828317722715, -0.05354120906105193 } };
    static const double coefficients13[1][15] = { { 0.2514157444218835, 0.35190873550605745, -0.20317460317460317, -0.13910414158861362, 0.10774960475223574, -0.062209263308779184, -0.19005243869327954, -0.02677060453052594, -0.1244185266175582, 0.15563831797545172, 0.0, -0.16998806888311374, 0.08380524814062784, 0.027820828317722708, -0.0535412090610519 } };
    static const double coefficients14[1][15] = { { 0.2514157444218835, 0.0, 0.4063492063492063, 0.0, 0.0, -0.18662778992633738, 0.0, -0.18739423171368175, 0.0, -0.2035270311986676, 0.0, 0.0, -0.16761049628125566, 0.0, 0.10708241812210383 } };
    const std::size_t reference_offset[15] = {};
    const std::size_t num_components[15] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[4][16][4] =
        { { { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 0, 1 },
            { 0, 0, 1, 0 },
            { 0, 0, 1, 1 },
            { 0, 1, 0, 0 },
            { 0, 1, 0, 1 },
            { 0, 1, 1, 0 },
            { 0, 1, 1, 1 },
            { 1, 0, 0, 0 },
            { 1, 0, 0, 1 },
            { 1, 0, 1, 0 },
            { 1, 0, 1, 1 },
            { 1, 1, 0, 0 },
            { 1, 1, 0, 1 },
            { 1, 1, 1, 0 },
            { 1, 1, 1, 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues4[15] = {};
        basisvalues4[0] = 1.0;
        const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues4[1] = tmp1_4;
        const double tmp2_4 = (1.0 - Y[1]) / 2.0;
        const double tmp3_4 = tmp2_4 * tmp2_4;
        basisvalues4[3] = 1.5 * tmp1_4 * basisvalues4[1] - 0.5 * tmp3_4 * basisvalues4[0];
        basisvalues4[6] = 1.6666666666666667 * tmp1_4 * basisvalues4[3] - 0.6666666666666666 * tmp3_4 * basisvalues4[1];
        basisvalues4[10] = 1.75 * tmp1_4 * basisvalues4[6] - 0.75 * tmp3_4 * basisvalues4[3];
        basisvalues4[2] = (0.5 + 1.5 * Y[1]) * basisvalues4[0];
        basisvalues4[4] = (1.5 + 2.5 * Y[1]) * basisvalues4[1];
        basisvalues4[7] = (2.5 + 3.5 * Y[1]) * basisvalues4[3];
        basisvalues4[11] = (3.5 + 4.5 * Y[1]) * basisvalues4[6];
        basisvalues4[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues4[2] - 0.5555555555555556 * basisvalues4[0];
        basisvalues4[9] = (0.05 + 1.75 * Y[1]) * basisvalues4[5] - 0.7 * basisvalues4[2];
        basisvalues4[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues4[9] - 0.7714285714285715 * basisvalues4[5];
        basisvalues4[8] = (0.54 + 2.1 * Y[1]) * basisvalues4[4] - 0.56 * basisvalues4[1];
        basisvalues4[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues4[8] - 0.7142857142857143 * basisvalues4[4];
        basisvalues4[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues4[7] - 0.5510204081632653 * basisvalues4[3];
        basisvalues4[0] *= std::sqrt(0.5);
        basisvalues4[2] *= std::sqrt(1.0);
        basisvalues4[5] *= std::sqrt(1.5);
        basisvalues4[9] *= std::sqrt(2.0);
        basisvalues4[14] *= std::sqrt(2.5);
        basisvalues4[1] *= std::sqrt(3.0);
        basisvalues4[4] *= std::sqrt(4.5);
        basisvalues4[8] *= std::sqrt(6.0);
        basisvalues4[13] *= std::sqrt(7.5);
        basisvalues4[3] *= std::sqrt(7.5);
        basisvalues4[7] *= std::sqrt(10.0);
        basisvalues4[12] *= std::sqrt(12.5);
        basisvalues4[6] *= std::sqrt(14.0);
        basisvalues4[11] *= std::sqrt(17.5);
        basisvalues4[10] *= std::sqrt(22.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 15; ++i)
        {
            double derivatives[16] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients6[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients7[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients8[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients9[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients10[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients11[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[15] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[15][15] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 225, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[15][15];
                        std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 225, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 15; ++s)
                        for (std::size_t t = 0; t < 15; ++t)
                            aux[s] += dmats[s][t] * basisvalues4[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 15; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[15 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[4][16][4] =
        { { { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 0, 1 },
            { 0, 0, 1, 0 },
            { 0, 0, 1, 1 },
            { 0, 1, 0, 0 },
            { 0, 1, 0, 1 },
            { 0, 1, 1, 0 },
            { 0, 1, 1, 1 },
            { 1, 0, 0, 0 },
            { 1, 0, 0, 1 },
            { 1, 0, 1, 0 },
            { 1, 0, 1, 1 },
            { 1, 1, 0, 0 },
            { 1, 1, 0, 1 },
            { 1, 1, 1, 0 },
            { 1, 1, 1, 1 } } };
    std::fill_n(values, num_points * 15 * num_derivatives, 0.0);
    const std::size_t reference_offsets[15] = {};
    const std::size_t physical_offsets[15] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[16][16];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 15; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[15 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[15 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[15];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[15];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 15; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[4][16][4] =
        { { { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 1, 0, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 1, 0, 0 },
            { 1, 0, 0, 0 },
            { 1, 1, 0, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 1, 0 },
            { 0, 1, 0, 0 },
            { 0, 1, 1, 0 },
            { 1, 0, 0, 0 },
            { 1, 0, 1, 0 },
            { 1, 1, 0, 0 },
            { 1, 1, 1, 0 } },
          { { 0, 0, 0, 0 },
            { 0, 0, 0, 1 },
            { 0, 0, 1, 0 },
            { 0, 0, 1, 1 },
            { 0, 1, 0, 0 },
            { 0, 1, 0, 1 },
            { 0, 1, 1, 0 },
            { 0, 1, 1, 1 },
            { 1, 0, 0, 0 },
            { 1, 0, 0, 1 },
            { 1, 0, 1, 0 },
            { 1, 0, 1, 1 },
            { 1, 1, 0, 0 },
            { 1, 1, 0, 1 },
            { 1, 1, 1, 0 },
            { 1, 1, 1, 1 } } };
    // Declare transformation matrix
    double transform[16][16] =
        { { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.0, -0.04123930494211609, -0.023809523809523822, 0.028980029497627822, 0.022447834323382442, 0.012960263189328967, -0.03959425806109992, -0.03346325566315744, -0.02592052637865797, -0.014965222882254974, 0.03212472543663117, 0.028331344813852292, 0.023944356611607955, 0.01854721887848184, 0.0107082418122104 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.0, 0.04123930494211613, -0.023809523809523784, 0.02898002949762785, -0.022447834323382466, 0.012960263189328984, 0.0395942580610999, -0.03346325566315744, 0.02592052637865797, -0.014965222882254966, 0.03212472543663116, -0.0283313448138523, 0.02394435661160794, -0.01854721887848182, 0.01070824181221038 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.0, 0.0, 0.04761904761904767, 0.0, 0.0, 0.038880789567987, 0.0, 0.0, 0.0, 0.059860891529019876, 0.0, 0.0, 0.0, 0.0, 0.05354120906105191 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094168, 0.13196577581477154, -0.025396825396825307, 0.13910414158861364, -0.07183306983482386, 0.031104631654389595, 0.06335081289775987, 0.026770604530525932, -0.0622092633087791, 0.047888713223215876, 0.0, 0.056662689627704585, -0.08380524814062787, 0.08346248495316817, -0.05354120906105193 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { -0.03142696805273548, 0.010997147984564424, 0.006349206349206469, 0.0, 0.1885618083164127, -0.16329931618554513, 0.0, 0.09369711585684087, 0.0, -0.04190262407031398, 0.0, 0.0, 0.08380524814062781, -0.13910414158861362, 0.10708241812210383 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094168, 0.0439885919382572, 0.12698412698412692, 0.0, 0.03591653491741195, 0.1555231582719478, 0.0, 0.0, 0.1036821055146319, -0.01197217830580397, 0.0, 0.0, 0.0, 0.09273609439240908, -0.10708241812210383 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094185, -0.13196577581477167, -0.025396825396825397, 0.13910414158861367, 0.07183306983482388, 0.031104631654389547, -0.06335081289775983, 0.02677060453052595, 0.062209263308779184, 0.04788871322321592, 0.0, -0.05666268962770455, -0.08380524814062786, -0.08346248495316819, -0.05354120906105191 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { -0.0314269680527354, -0.010997147984564262, 0.006349206349206462, 0.0, -0.18856180831641273, -0.16329931618554513, 0.0, 0.09369711585684086, 0.0, -0.041902624070313955, 0.0, 0.0, 0.08380524814062786, 0.13910414158861364, 0.1070824181221038 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094185, -0.04398859193825722, 0.12698412698412698, 0.0, -0.03591653491741193, 0.15552315827194774, 0.0, 0.0, -0.1036821055146319, -0.01197217830580399, 0.0, 0.0, 0.0, -0.09273609439240911, -0.1070824181221038 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094204, -0.08797718387651439, -0.10158730158730161, 0.09273609439240908, 0.10774960475223586, 0.07257747386024233, 0.0791885161221998, -0.01338530226526298, -0.05184105275731595, -0.041902624070313935, -0.12849890174652465, -0.0566626896277046, -0.011972178305803964, 0.009273609439240882, 0.010708241812210384 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { -0.03142696805273535, 0.0, -0.012698412698412615, -0.24343224778007383, 0.0, 0.05443310539518173, 0.0, 0.09369711585684086, 0.0, -0.041902624070313955, 0.19274835261978693, 0.0, -0.02394435661160798, 0.0, 0.010708241812210403 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.12570787221094196, 0.08797718387651435, -0.10158730158730156, 0.09273609439240904, -0.10774960475223587, 0.07257747386024228, -0.07918851612219983, -0.013385302265262985, 0.05184105275731593, -0.041902624070313914, -0.1284989017465246, 0.05666268962770457, -0.011972178305803974, -0.009273609439240903, 0.010708241812210383 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.25141574442188375, -0.35190873550605756, -0.20317460317460326, -0.13910414158861362, -0.10774960475223579, -0.062209263308779135, 0.19005243869327954, -0.02677060453052593, 0.12441852661755824, 0.15563831797545175, 0.0, 0.16998806888311374, 0.08380524814062784, -0.027820828317722715, -0.05354120906105193 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.2514157444218835, 0.35190873550605745, -0.20317460317460317, -0.13910414158861362, 0.10774960475223574, -0.062209263308779184, -0.19005243869327954, -0.02677060453052594, -0.1244185266175582, 0.15563831797545172, 0.0, -0.16998806888311374, 0.08380524814062784, 0.027820828317722708, -0.0535412090610519 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[15] = {};
            basisvalues[0] = 1.0;
            const double tmp1_4 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_4;
            const double tmp2_4 = (1.0 - Y[1]) / 2.0;
            const double tmp3_4 = tmp2_4 * tmp2_4;
            basisvalues[3] = 1.5 * tmp1_4 * basisvalues[1] - 0.5 * tmp3_4 * basisvalues[0];
            basisvalues[6] = 1.6666666666666667 * tmp1_4 * basisvalues[3] - 0.6666666666666666 * tmp3_4 * basisvalues[1];
            basisvalues[10] = 1.75 * tmp1_4 * basisvalues[6] - 0.75 * tmp3_4 * basisvalues[3];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[7] = (2.5 + 3.5 * Y[1]) * basisvalues[3];
            basisvalues[11] = (3.5 + 4.5 * Y[1]) * basisvalues[6];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[9] = (0.05 + 1.75 * Y[1]) * basisvalues[5] - 0.7 * basisvalues[2];
            basisvalues[14] = (0.02857142857142857 + 1.8 * Y[1]) * basisvalues[9] - 0.7714285714285715 * basisvalues[5];
            basisvalues[8] = (0.54 + 2.1 * Y[1]) * basisvalues[4] - 0.56 * basisvalues[1];
            basisvalues[13] = (0.2857142857142857 + 2.0 * Y[1]) * basisvalues[8] - 0.7142857142857143 * basisvalues[4];
            basisvalues[12] = (1.0204081632653061 + 2.5714285714285716 * Y[1]) * basisvalues[7] - 0.5510204081632653 * basisvalues[3];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[9] *= std::sqrt(2.0);
            basisvalues[14] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[8] *= std::sqrt(6.0);
            basisvalues[13] *= std::sqrt(7.5);
            basisvalues[3] *= std::sqrt(7.5);
            basisvalues[7] *= std::sqrt(10.0);
            basisvalues[12] *= std::sqrt(12.5);
            basisvalues[6] *= std::sqrt(14.0);
            basisvalues[11] *= std::sqrt(17.5);
            basisvalues[10] *= std::sqrt(22.5);
            // Table(s) of coefficients
            static const double coefficients0[15] = { 0.2514157444218835, 0.0, 0.4063492063492063, 0.0, 0.0, -0.18662778992633738, 0.0, -0.18739423171368175, 0.0, -0.2035270311986676, 0.0, 0.0, -0.16761049628125566, 0.0, 0.10708241812210383 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505147, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.29150262212921, -6.058441774868359e-14, -2.9933259094191693, 13.662601021279473, 1.364279788597637e-14, 0.6110100926607878, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.0244556673254842e-14, 4.38178046004133, 0.0, 0.0, 12.521980673998838, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.464101615137766, 0.0, 7.838367176906182, 0.0, 0.0, 8.40000000000002, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -5.595185198247997e-14, 10.954451150103306, 3.8328396494740634e-14, -8.730238864208682e-14, -3.8332593899996485, -1.9297498272218237e-14, 17.74823934929884, 1.719500595523367e-14, 0.5532833351724962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.732863826479687, -4.0463756225221976e-14, 3.3466401061362907, 4.364357804719845, -6.803961224120785e-14, -5.074680379332367, 0.0, 17.008401285415214, 1.7925427654883235e-14, 1.5212776585113215, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -1.2185993662168334e-14, 2.4494897427831663, -1.0495666335244917e-14, 0.0, 9.142857142857078, -1.7796081680727237e-14, 0.0, 0.0, 14.846149779161808, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.0983866769659474, 0.0, 7.668115805072359, 0.0, 0.0, 10.733126291999028, 0.0, 0.0, 0.0, 9.295160030897799, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[15][15] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.4494897427831805, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.91287092917528, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999107, 6.123724356957937, 3.535533905932737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.309401076758488, 0.0, 8.16496580927727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.645751311064579, 5.184592558726252, -1.4966629547095678, 6.831300510639735, -1.0583005244258321, 0.3055050463303929, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2360679774998298, 2.1908902300206603, 2.5298221281346867, 8.082903768654784, 6.260990336999423, -1.8073922282301171, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.732050807568886, -5.091168824543144, 3.919183588453092, 0.0, 9.699484522385703, 4.200000000000017, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.0000000000000275, 0.0, -2.8284271247462307, 0.0, 0.0, 12.124355652982166, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.6832815729997224, 5.477225575051648, -1.897366596101009, 7.4230748895808665, -1.9166296949998254, 0.6639400022069775, 8.874119674649426, -1.0714285714285636, 0.2766416675862469, -0.09583148474998932, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.3664319132398295, 2.8982753492378506, 1.6733200530681467, 2.182178902359859, 5.747048932153885, -2.537340189666181, 10.062305898749047, 8.50420064270763, -2.1957751641341874, 0.7606388292556634, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.9999999999999971, 1.224744871391584, 3.5355339059327187, -7.377111135633236, 4.571428571428534, 1.6495721976846638, 0.0, 11.499778169998926, 7.4230748895809056, -2.571428571428573, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.5491933384829095, 6.640783086353566, 3.8340579025361654, 0.0, -6.196773353931827, 5.3665631459995184, 0.0, 0.0, 13.416407864998732, 4.647580015448903, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.5777087639996905, 0.0, 8.854377448471439, 0.0, 0.0, -3.098386676965972, 0.0, 0.0, 0.0, 16.099689437998478, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[16] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[15][15] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 225, 0.0);
                for (std::size_t t = 0; t < 15; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 225, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 225, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 15; ++t)
                            for (std::size_t u = 0; u < 15; ++u)
                                for (std::size_t tu = 0; tu < 15; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 15; ++s)
                    for (std::size_t t = 0; t < 15; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 15, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 4)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[16] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 15; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.75 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
            y[1] = 0.75 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.25 * coordinate_dofs[2] + 0.75 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[3] + 0.75 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 6:
        {
            y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[4];
            y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 8:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 9:
        {
            y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2];
            y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 11:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[2];
            y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 12:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 13:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 14:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.75 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    y[1] = 0.75 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25 * coordinate_dofs[2] + 0.75 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[3] + 0.75 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[4];
    y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2];
    y[1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[10] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[2];
    y[1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[11] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[12] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[13] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[14] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = 0.75 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 3 + 1] = 0.75 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 4] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 4 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 5] = 0.25 * coordinate_dofs[2] + 0.75 * coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = 0.25 * coordinate_dofs[3] + 0.75 * coordinate_dofs[5];
    dof_coordinates[2 * 6] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 6 + 1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 7 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 8] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[5];
    dof_coordinates[2 * 9] = 0.75 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2];
    dof_coordinates[2 * 9 + 1] = 0.75 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3];
    dof_coordinates[2 * 10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 10 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 11] = 0.25 * coordinate_dofs[0] + 0.75 * coordinate_dofs[2];
    dof_coordinates[2 * 11 + 1] = 0.25 * coordinate_dofs[1] + 0.75 * coordinate_dofs[3];
    dof_coordinates[2 * 12] = 0.5 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 12 + 1] = 0.5 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 13] = 0.25 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2] + 0.25 * coordinate_dofs[4];
    dof_coordinates[2 * 13 + 1] = 0.25 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3] + 0.25 * coordinate_dofs[5];
    dof_coordinates[2 * 14] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 14 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[30] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.75, 0.25, 0.5, 0.5, 0.25, 0.75, 0.0, 0.25, 0.0, 0.5, 0.0, 0.75, 0.25, 0.0, 0.5, 0.0, 0.75, 0.0, 0.25, 0.25, 0.5, 0.25, 0.25, 0.5 };
    std::copy_n(dof_X, 30, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new converge_finite_element_2();
  }

};


class converge_dofmap_0: public ufc::dofmap
{
public:

  converge_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  ~converge_dofmap_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Lagrange', triangle, 1)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[0];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 3;
  }

  std::size_t num_element_dofs() const final override
  {
    return 3;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 2;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 1, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 1, 2, 3 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new converge_dofmap_0();
  }

};


class converge_dofmap_1: public ufc::dofmap
{
public:

  converge_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  ~converge_dofmap_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 2 * num_global_entities[0];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 6;
  }

  std::size_t num_element_dofs() const final override
  {
    return 6;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 4;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 2, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 2, 4, 6 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 2;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new converge_dofmap_0();
    case 1:
        return new converge_dofmap_0();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new converge_dofmap_1();
  }

};


class converge_dofmap_2: public ufc::dofmap
{
public:

  converge_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  ~converge_dofmap_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', triangle, 4)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { false, false, true };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 15 * num_global_entities[2];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 15;
  }

  std::size_t num_element_dofs() const final override
  {
    return 15;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 0, 0, 15 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 0, 0, 15 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = 15 * entity_indices[2][0];
    dofs[1] = 15 * entity_indices[2][0] + 1;
    dofs[2] = 15 * entity_indices[2][0] + 2;
    dofs[3] = 15 * entity_indices[2][0] + 3;
    dofs[4] = 15 * entity_indices[2][0] + 4;
    dofs[5] = 15 * entity_indices[2][0] + 5;
    dofs[6] = 15 * entity_indices[2][0] + 6;
    dofs[7] = 15 * entity_indices[2][0] + 7;
    dofs[8] = 15 * entity_indices[2][0] + 8;
    dofs[9] = 15 * entity_indices[2][0] + 9;
    dofs[10] = 15 * entity_indices[2][0] + 10;
    dofs[11] = 15 * entity_indices[2][0] + 11;
    dofs[12] = 15 * entity_indices[2][0] + 12;
    dofs[13] = 15 * entity_indices[2][0] + 13;
    dofs[14] = 15 * entity_indices[2][0] + 14;
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new converge_dofmap_2();
  }

};


class converge_coordinate_mapping_1: public ufc::coordinate_mapping
{
public:

  converge_coordinate_mapping_1() : ufc::coordinate_mapping()
  {
    // Do nothing
  }

  ~converge_coordinate_mapping_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  }

  ufc::coordinate_mapping * create() const final override
  {
    return new converge_coordinate_mapping_1();
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new converge_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new converge_dofmap_1();
  }

  void compute_physical_coordinates(
      double * x, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs) const final override
  {
    converge_finite_element_0 xelement;
    double phi[3];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[2 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t d = 0; d < 3; ++d)
                x[2 * ip + i] += coordinate_dofs[2 * d + i] * phi[d];
    }
  }

  void compute_reference_coordinates(
      double * X, std::size_t num_points,
      const double * x,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double J[4];
    double detJ[1];
    double K[4];
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
  }

  void compute_reference_geometry(
      double * X, double * J, double * detJ, double * K, std::size_t num_points,
      const double * x,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
  }

  void compute_jacobians(
      double * J, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs) const final override
  {
    converge_finite_element_0 xelement;
    double dphi[6];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[2 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t j = 0; j < 2; ++j)
                for (std::size_t d = 0; d < 3; ++d)
                    J[2 * 2 * ip + 2 * i + j] += coordinate_dofs[2 * d + i] * dphi[2 * d + j];
    }
  }

  void compute_jacobian_determinants(
      double * detJ, std::size_t num_points,
      const double * J,
      int cell_orientation) const final override
  {
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[2 * 2 * ip] * J[2 * 2 * ip + 2 + 1] - J[2 * 2 * ip + 1] * J[2 * 2 * ip + 2];
  }

  void compute_jacobian_inverses(
      double * K, std::size_t num_points,
      const double * J, const double * detJ) const final override
  {
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[2 * 2 * ip] = J[2 * 2 * ip + 2 + 1] / detJ[ip];
        K[2 * 2 * ip + 1] = -J[2 * 2 * ip + 1] / detJ[ip];
        K[2 * 2 * ip + 2] = -J[2 * 2 * ip + 2] / detJ[ip];
        K[2 * 2 * ip + 2 + 1] = J[2 * 2 * ip] / detJ[ip];
    }
  }

  void compute_geometry(
      double * x, double * J, double * detJ, double * K, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
  }

  void compute_midpoint_geometry(
      double * x, double * J,
      const double * coordinate_dofs) const final override
  {
    const double phi_Xm[3] = { 0.33333333333333337, 0.33333333333333337, 0.3333333333333333 };
    const double dphi_Xm[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t d = 0; d < 3; ++d)
            x[i] += coordinate_dofs[2 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t d = 0; d < 3; ++d)
                J[2 * i + j] += coordinate_dofs[2 * d + i] * dphi_Xm[j][d];
  }

};


class converge_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  converge_cell_integral_0_otherwise() : ufc::cell_integral()
  {

  }

  ~converge_cell_integral_0_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 8
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 8
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           8
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q25[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q25[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q25[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q25[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q25[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q25[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    A[0] = 0.002557319223985888 * sp[3];
    A[1] = -0.0002380952380952378 * sp[3];
    A[2] = -0.000238095238095238 * sp[3];
    A[3] = -0.0009876543209876498 * sp[3];
    A[4] = -0.0001058201058201089 * sp[3];
    A[5] = -0.0009876543209876511 * sp[3];
    A[6] = 0.001410934744268073 * sp[3];
    A[7] = -0.0007054673721340345 * sp[3];
    A[8] = 0.0;
    A[9] = 0.001410934744268076 * sp[3];
    A[10] = -0.0007054673721340357 * sp[3];
    A[11] = 0.0;
    A[12] = 0.001410934744268081 * sp[3];
    A[13] = -0.001410934744268064 * sp[3];
    A[14] = -0.001410934744268072 * sp[3];
    A[15] = -0.0002380952380952378 * sp[3];
    A[16] = 0.002557319223985887 * sp[3];
    A[17] = -0.0002380952380952371 * sp[3];
    A[18] = 0.001410934744268072 * sp[3];
    A[19] = -0.0007054673721340348 * sp[3];
    A[20] = 0.0;
    A[21] = -0.0009876543209876533 * sp[3];
    A[22] = -0.0001058201058201071 * sp[3];
    A[23] = -0.0009876543209876522 * sp[3];
    A[24] = 0.0;
    A[25] = -0.0007054673721340375 * sp[3];
    A[26] = 0.001410934744268073 * sp[3];
    A[27] = -0.001410934744268078 * sp[3];
    A[28] = 0.001410934744268077 * sp[3];
    A[29] = -0.00141093474426807 * sp[3];
    A[30] = -0.000238095238095238 * sp[3];
    A[31] = -0.0002380952380952371 * sp[3];
    A[32] = 0.00255731922398589 * sp[3];
    A[33] = 0.0;
    A[34] = -0.0007054673721340384 * sp[3];
    A[35] = 0.001410934744268078 * sp[3];
    A[36] = 0.0;
    A[37] = -0.0007054673721340375 * sp[3];
    A[38] = 0.001410934744268076 * sp[3];
    A[39] = -0.0009876543209876535 * sp[3];
    A[40] = -0.0001058201058201048 * sp[3];
    A[41] = -0.000987654320987652 * sp[3];
    A[42] = -0.001410934744268081 * sp[3];
    A[43] = -0.001410934744268077 * sp[3];
    A[44] = 0.001410934744268077 * sp[3];
    A[45] = -0.0009876543209876498 * sp[3];
    A[46] = 0.001410934744268072 * sp[3];
    A[47] = 0.0;
    A[48] = 0.02257495590828921 * sp[3];
    A[49] = -0.01128747795414461 * sp[3];
    A[50] = 0.006772486772486761 * sp[3];
    A[51] = 0.002257495590828924 * sp[3];
    A[52] = 0.0005643738977072397 * sp[3];
    A[53] = 0.004514991181657843 * sp[3];
    A[54] = 0.004514991181657852 * sp[3];
    A[55] = -0.008465608465608464 * sp[3];
    A[56] = 0.01128747795414461 * sp[3];
    A[57] = -0.00225749559082892 * sp[3];
    A[58] = 0.0112874779541446 * sp[3];
    A[59] = 0.002257495590828935 * sp[3];
    A[60] = -0.0001058201058201089 * sp[3];
    A[61] = -0.0007054673721340348 * sp[3];
    A[62] = -0.0007054673721340384 * sp[3];
    A[63] = -0.01128747795414461 * sp[3];
    A[64] = 0.02793650793650791 * sp[3];
    A[65] = -0.0112874779541446 * sp[3];
    A[66] = 0.0005643738977072362 * sp[3];
    A[67] = 0.0004232804232804 * sp[3];
    A[68] = -0.00846560846560844 * sp[3];
    A[69] = 0.000564373897707235 * sp[3];
    A[70] = 0.0004232804232804208 * sp[3];
    A[71] = -0.008465608465608454 * sp[3];
    A[72] = -0.006772486772486806 * sp[3];
    A[73] = 0.003386243386243403 * sp[3];
    A[74] = 0.003386243386243398 * sp[3];
    A[75] = -0.0009876543209876511 * sp[3];
    A[76] = 0.0;
    A[77] = 0.001410934744268078 * sp[3];
    A[78] = 0.006772486772486761 * sp[3];
    A[79] = -0.0112874779541446 * sp[3];
    A[80] = 0.0225749559082892 * sp[3];
    A[81] = 0.004514991181657842 * sp[3];
    A[82] = -0.008465608465608444 * sp[3];
    A[83] = 0.0112874779541446 * sp[3];
    A[84] = 0.002257495590828923 * sp[3];
    A[85] = 0.0005643738977072377 * sp[3];
    A[86] = 0.004514991181657842 * sp[3];
    A[87] = -0.002257495590828926 * sp[3];
    A[88] = 0.002257495590828913 * sp[3];
    A[89] = 0.01128747795414462 * sp[3];
    A[90] = 0.001410934744268073 * sp[3];
    A[91] = -0.0009876543209876533 * sp[3];
    A[92] = 0.0;
    A[93] = 0.002257495590828924 * sp[3];
    A[94] = 0.0005643738977072362 * sp[3];
    A[95] = 0.004514991181657842 * sp[3];
    A[96] = 0.02257495590828924 * sp[3];
    A[97] = -0.01128747795414461 * sp[3];
    A[98] = 0.006772486772486764 * sp[3];
    A[99] = 0.01128747795414463 * sp[3];
    A[100] = -0.00846560846560847 * sp[3];
    A[101] = 0.004514991181657857 * sp[3];
    A[102] = 0.01128747795414465 * sp[3];
    A[103] = -0.002257495590828935 * sp[3];
    A[104] = 0.00225749559082893 * sp[3];
    A[105] = -0.0007054673721340345 * sp[3];
    A[106] = -0.0001058201058201071 * sp[3];
    A[107] = -0.0007054673721340375 * sp[3];
    A[108] = 0.0005643738977072397 * sp[3];
    A[109] = 0.0004232804232804 * sp[3];
    A[110] = -0.008465608465608444 * sp[3];
    A[111] = -0.01128747795414461 * sp[3];
    A[112] = 0.02793650793650792 * sp[3];
    A[113] = -0.01128747795414459 * sp[3];
    A[114] = -0.008465608465608463 * sp[3];
    A[115] = 0.0004232804232804276 * sp[3];
    A[116] = 0.0005643738977072375 * sp[3];
    A[117] = 0.003386243386243375 * sp[3];
    A[118] = -0.006772486772486761 * sp[3];
    A[119] = 0.003386243386243392 * sp[3];
    A[120] = 0.0;
    A[121] = -0.0009876543209876522 * sp[3];
    A[122] = 0.001410934744268076 * sp[3];
    A[123] = 0.004514991181657843 * sp[3];
    A[124] = -0.00846560846560844 * sp[3];
    A[125] = 0.0112874779541446 * sp[3];
    A[126] = 0.006772486772486764 * sp[3];
    A[127] = -0.01128747795414459 * sp[3];
    A[128] = 0.02257495590828923 * sp[3];
    A[129] = 0.004514991181657849 * sp[3];
    A[130] = 0.0005643738977072307 * sp[3];
    A[131] = 0.002257495590828926 * sp[3];
    A[132] = 0.002257495590828931 * sp[3];
    A[133] = -0.002257495590828928 * sp[3];
    A[134] = 0.01128747795414463 * sp[3];
    A[135] = 0.001410934744268076 * sp[3];
    A[136] = 0.0;
    A[137] = -0.0009876543209876535 * sp[3];
    A[138] = 0.004514991181657852 * sp[3];
    A[139] = 0.000564373897707235 * sp[3];
    A[140] = 0.002257495590828923 * sp[3];
    A[141] = 0.01128747795414463 * sp[3];
    A[142] = -0.008465608465608463 * sp[3];
    A[143] = 0.004514991181657849 * sp[3];
    A[144] = 0.02257495590828924 * sp[3];
    A[145] = -0.01128747795414462 * sp[3];
    A[146] = 0.006772486772486777 * sp[3];
    A[147] = 0.01128747795414463 * sp[3];
    A[148] = 0.002257495590828937 * sp[3];
    A[149] = -0.002257495590828898 * sp[3];
    A[150] = -0.0007054673721340357 * sp[3];
    A[151] = -0.0007054673721340375 * sp[3];
    A[152] = -0.0001058201058201048 * sp[3];
    A[153] = -0.008465608465608464 * sp[3];
    A[154] = 0.0004232804232804208 * sp[3];
    A[155] = 0.0005643738977072377 * sp[3];
    A[156] = -0.00846560846560847 * sp[3];
    A[157] = 0.0004232804232804276 * sp[3];
    A[158] = 0.0005643738977072307 * sp[3];
    A[159] = -0.01128747795414462 * sp[3];
    A[160] = 0.02793650793650792 * sp[3];
    A[161] = -0.01128747795414461 * sp[3];
    A[162] = 0.003386243386243366 * sp[3];
    A[163] = 0.003386243386243382 * sp[3];
    A[164] = -0.006772486772486751 * sp[3];
    A[165] = 0.0;
    A[166] = 0.001410934744268073 * sp[3];
    A[167] = -0.000987654320987652 * sp[3];
    A[168] = 0.01128747795414461 * sp[3];
    A[169] = -0.008465608465608454 * sp[3];
    A[170] = 0.004514991181657842 * sp[3];
    A[171] = 0.004514991181657857 * sp[3];
    A[172] = 0.0005643738977072375 * sp[3];
    A[173] = 0.002257495590828926 * sp[3];
    A[174] = 0.006772486772486777 * sp[3];
    A[175] = -0.01128747795414461 * sp[3];
    A[176] = 0.02257495590828921 * sp[3];
    A[177] = 0.002257495590828954 * sp[3];
    A[178] = 0.0112874779541446 * sp[3];
    A[179] = -0.002257495590828896 * sp[3];
    A[180] = 0.001410934744268081 * sp[3];
    A[181] = -0.001410934744268078 * sp[3];
    A[182] = -0.001410934744268081 * sp[3];
    A[183] = -0.00225749559082892 * sp[3];
    A[184] = -0.006772486772486806 * sp[3];
    A[185] = -0.002257495590828926 * sp[3];
    A[186] = 0.01128747795414465 * sp[3];
    A[187] = 0.003386243386243375 * sp[3];
    A[188] = 0.002257495590828931 * sp[3];
    A[189] = 0.01128747795414463 * sp[3];
    A[190] = 0.003386243386243366 * sp[3];
    A[191] = 0.002257495590828954 * sp[3];
    A[192] = 0.09481481481481489 * sp[3];
    A[193] = -0.0135449735449735 * sp[3];
    A[194] = -0.01354497354497356 * sp[3];
    A[195] = -0.001410934744268064 * sp[3];
    A[196] = 0.001410934744268077 * sp[3];
    A[197] = -0.001410934744268077 * sp[3];
    A[198] = 0.0112874779541446 * sp[3];
    A[199] = 0.003386243386243403 * sp[3];
    A[200] = 0.002257495590828913 * sp[3];
    A[201] = -0.002257495590828935 * sp[3];
    A[202] = -0.006772486772486761 * sp[3];
    A[203] = -0.002257495590828928 * sp[3];
    A[204] = 0.002257495590828937 * sp[3];
    A[205] = 0.003386243386243382 * sp[3];
    A[206] = 0.0112874779541446 * sp[3];
    A[207] = -0.0135449735449735 * sp[3];
    A[208] = 0.09481481481481481 * sp[3];
    A[209] = -0.01354497354497352 * sp[3];
    A[210] = -0.001410934744268072 * sp[3];
    A[211] = -0.00141093474426807 * sp[3];
    A[212] = 0.001410934744268077 * sp[3];
    A[213] = 0.002257495590828935 * sp[3];
    A[214] = 0.003386243386243398 * sp[3];
    A[215] = 0.01128747795414462 * sp[3];
    A[216] = 0.00225749559082893 * sp[3];
    A[217] = 0.003386243386243392 * sp[3];
    A[218] = 0.01128747795414463 * sp[3];
    A[219] = -0.002257495590828898 * sp[3];
    A[220] = -0.006772486772486751 * sp[3];
    A[221] = -0.002257495590828896 * sp[3];
    A[222] = -0.01354497354497356 * sp[3];
    A[223] = -0.01354497354497352 * sp[3];
    A[224] = 0.09481481481481478 * sp[3];
  }

};


class converge_cell_integral_1_otherwise: public ufc::cell_integral
{
public:

  converge_cell_integral_1_otherwise() : ufc::cell_integral()
  {

  }

  ~converge_cell_integral_1_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({true, true});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 14
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 14
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           14
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights64[64] = { 0.002254906358039607, 0.004611922695459142, 0.005694398702308253, 0.005367509486579306, 0.004008629765695745, 0.002299877901745705, 0.0009031054595185747, 0.0001667837032477104, 0.004953626979826357, 0.01013157136731911, 0.01250957803416992, 0.01179146074620547, 0.008806244431697445, 0.005052421438156166, 0.001983961575144538, 0.0003663940408245987, 0.006987941703712829, 0.01429232164031734, 0.01764690849691113, 0.01663388071642617, 0.01242272035580374, 0.007127308256396373, 0.00279871857246754, 0.000516861727436696, 0.008078927139199171, 0.01652369611509118, 0.02040201450205438, 0.01923082876875408, 0.01436220519296266, 0.008240052156051197, 0.003235665720862452, 0.0005975562496154, 0.008078927139199166, 0.01652369611509117, 0.02040201450205437, 0.01923082876875407, 0.01436220519296266, 0.008240052156051194, 0.003235665720862451, 0.0005975562496153998, 0.006987941703712831, 0.01429232164031734, 0.01764690849691113, 0.01663388071642617, 0.01242272035580374, 0.007127308256396374, 0.00279871857246754, 0.000516861727436696, 0.004953626979826357, 0.01013157136731911, 0.01250957803416992, 0.01179146074620547, 0.008806244431697445, 0.005052421438156166, 0.001983961575144538, 0.0003663940408245987, 0.002254906358039612, 0.004611922695459152, 0.005694398702308265, 0.005367509486579317, 0.004008629765695754, 0.002299877901745709, 0.0009031054595185768, 0.0001667837032477107 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE11_C0_D01_Q64[1][64][14] =
        { { { -6.702492895031697, -0.7541621137532887, 0.09215684366281507, 0.06169265406411295, 0.08260839951335219, 12.43770781232634, -8.974063562261414, 3.993010758720074, -1.216013464196428, 0.482009028275186, -0.0921568436627771, 1.638440306308481, -0.5437016823393297, -0.505035241625412 },
            { -4.130664483955383, -0.02841055147482241, 0.08605744093852541, 0.01803955820914416, 0.01003383303811889, 4.955797118459796, -1.039366106342136, 0.2426440233125493, -0.8996768614871264, 0.4101303108515207, -0.08605744093849518, 0.99470901412238, -0.4281698690606962, -0.1050659856733722 },
            { -1.314398438452779, 0.3585999529709629, 0.07557429239132857, -0.04180073037975174, -0.03905621079568677, -2.233063289133513, 5.210107733792491, -2.021245959177156, -0.498523645109982, 0.3019343573441219, -0.07557429239130692, 0.247644396895567, -0.2601336269643965, 0.2899354590101038 },
            { 0.2077514281485857, 0.01022488612900982, 0.06161488466007084, -0.09362320594829004, -0.009522753413827523, -4.261411496060703, 4.265720151233198, -0.2222849694500831, -0.1800966554902425, 0.1860078098109618, -0.06161488466005805, -0.2232721309610517, -0.09238460386269323, 0.4128915398651223 },
            { 0.2208119589055844, -0.3569762729465336, 0.04558378011935937, -0.1170359358573485, 0.07663730402840563, -1.422946925664479, -1.913815605713227, 3.472926845418662, -0.02022525343506186, 0.0893487008961968, -0.04558378011935245, -0.3034157383567322, 0.02768723496113523, 0.2470036877633877 },
            { -0.277608949822316, 0.5228639416176871, 0.02934298998550994, -0.1047459626045886, 0.1411962424529658, 1.731612273611224, -5.942550368834308, 3.965683103427717, 0.01448006822334409, 0.02780458653984559, -0.02934298998550211, -0.1559548404561206, 0.07694137606472506, 0.0002785297798122421 },
            { -0.2351458007909084, 3.135194050808042, 0.01502556386619314, -0.06624889579239834, 0.1269321485689692, 1.22721236509193, -2.530236976133759, -1.597023638975302, 0.003324495428087659, 0.001496094536892645, -0.01502556386617854, -0.01599256961961482, 0.06475280125547189, -0.1142640743774312 },
            { 0.4466595727066591, 6.405996726093937, 0.004701353278749654, -0.02346465400124131, 0.05407532960101946, -2.478789098201515, 6.049541475088419, -10.4234086756875, -0.002462293373278523, -0.002296042889469052, -0.004701353278724452, 0.0165873878031344, 0.02576069689065186, -0.06820042403085225 },
            { -3.881165331863508, -0.7541621137532889, 0.2559695676751765, 0.2057656277564166, 0.4229915932493955, 8.240123708216304, -7.257423827583521, 3.652627564984025, -4.84496758673029, 1.453448311653225, -0.2559695676751471, 6.787723943476484, -1.659213939409668, -2.365747949995602 },
            { -2.195702538903283, -0.02841055147482274, 0.2532418076827073, 0.06276666609457515, 0.05137766919821041, 2.733195445665645, -0.710382542439985, 0.2013001871524553, -3.545770720485283, 1.288446591541764, -0.2532418076826837, 3.973169708748014, -1.351213257636362, -0.4787766574609491 },
            { -0.4419604658421769, 0.3585999529709627, 0.2435864462001771, -0.1553432478702388, -0.1999850974970578, -2.302700171633248, 4.246377756980255, -1.860317072475784, -1.911281417908147, 1.010266311340536, -0.2435864462001596, 0.744058562092373, -0.854923063470318, 1.367207953312828 },
            { 0.3416793456341702, 0.01022488612900965, 0.2211877723727634, -0.3756883806949136, -0.0487607151617041, -3.222754333776144, 3.053897109715179, -0.1830470077022062, -0.6366746692513326, 0.6682307937991606, -0.2211877723727522, -1.221344371716736, -0.2925424131042645, 1.90677975612977 },
            { 0.1102983504746557, -0.3569762729465336, 0.1824096788487753, -0.5067393534105765, 0.3924169397336169, -0.5536654542778151, -2.356803832963752, 3.157147209713451, -0.02552328453178847, 0.3419862391532655, -0.1824096788487674, -1.446588987768975, 0.1647531142572956, 1.079695332567144 },
            { -0.3221937484597416, 0.5228639416176872, 0.1293700827346334, -0.4848294607431486, 0.7229872979970539, 1.876019774931546, -5.460582015973118, 3.38389204788363, 0.07754220041179744, 0.109354345737939, -0.1293700827346246, -0.6989231734660346, 0.3754751150051908, -0.1016063249428159 },
            { -0.187849522018165, 3.135194050808042, 0.0715200757588601, -0.323011731632759, 0.649948819660688, 0.9429274132200947, -1.770231631942949, -2.120040310067019, 0.01194582226112806, 0.002073000823773596, -0.07152007575884423, -0.04438805919392408, 0.3209387308089497, -0.6175065827278816 },
            { 0.4863422154329217, 6.405996726093937, 0.02354660260006458, -0.1183882374480074, 0.2768896378353389, -2.675119336852053, 6.429003379247012, -10.64622298392181, -0.01349068831899491, -0.01210504134870083, -0.02354660260003905, 0.08933979522635971, 0.1304932787966488, -0.3527387447426795 },
            { -0.9883599063437738, -0.7541621137532881, 0.04508216707856993, 0.05431460455692294, 0.9870276151313644, 3.456964862287975, -4.803034385292948, 3.088591543102049, -6.81141600117795, 0.3162038999845473, -0.04508216707854767, 10.49307475513324, -0.3705185045414949, -4.668686369086665 },
            { -0.3130854122260169, -0.02841055147482247, 0.09007507461638131, 0.03199441186761942, 0.1198869649161478, 0.4788293257206432, -0.2701242534543078, 0.1327908914345164, -4.842841279165558, 0.5397332904784492, -0.09007507461636514, 5.611217006469062, -0.5717277023460847, -0.888262692219665 },
            { 0.2661918638050489, 0.3585999529709626, 0.1586395385175451, -0.1355311300638106, -0.4666542243262908, -1.888520498862442, 2.857376627732992, -1.593647945646551, -2.413892260678398, 0.7197779167809315, -0.1586395385175326, 0.1441495202510151, -0.5842467867171345, 2.736396964753664 },
            { 0.2988067218574745, 0.01022488612900951, 0.2253752990523108, -0.4756601588791116, -0.1137804466240976, -1.604263325638556, 1.413258993891895, -0.1180272762398122, -0.6034191280457017, 0.6820354030497726, -0.2253752990523011, -2.930190075467463, -0.2063752441706737, 3.647389650137255 },
            { -0.09266752798395873, -0.3569762729465333, 0.2565083363394441, -0.8246410653337858, 0.915683342988018, 0.578764767378724, -2.763001772907274, 2.633880806459051, 0.1580038531750766, 0.43552363739568, -0.256508336339435, -2.877482180596981, 0.3891174279380909, 1.803794984433882 },
            { -0.3580666001608356, 0.5228639416176879, 0.2281844338076587, -0.9321268700606185, 1.687051090142065, 1.894780549620203, -4.47940614681567, 2.41982825573862, 0.1729629514338113, 0.1486207974900401, -0.2281844338076474, -1.224529256793086, 0.7835060725705569, -0.6354847847827899 },
            { -0.08998785659975195, 3.135194050808042, 0.1468381458582593, -0.6910439373425659, 1.516619818609263, 0.3949211397749348, -0.4534160249676287, -2.986711309015592, 0.00555111996246338, -0.01407589219657918, -0.1468381458582416, 0.04411904542167822, 0.7051198295391092, -1.566289983993395 },
            { 0.5546215238356182, 6.405996726093939, 0.05293578158625634, -0.269442536472372, 0.6461067388780126, -3.009213362808901, 7.064035197843836, -11.01544008496449, -0.03497228180464007, -0.02951357727956172, -0.05293578158622991, 0.2255818072417912, 0.2989561137518741, -0.8367162643151449 },
            { 0.313268858675521, -0.7541621137532881, -0.2557615078879876, -0.8311899085746113, 1.698688328267633, 0.4646363432071565, -2.400673918095153, 2.376930829965779, -4.561163917042502, -3.536520624136755, 0.2557615078880031, 9.048017911927772, 4.367710532711347, -6.185542323152919 },
            { 0.3585742829570704, -0.02841055147482208, -0.2470775524207932, -0.1934994457182486, 0.2063271431239383, -0.4752093195188423, 0.09869487480988326, 0.04635071322672446, -2.940726092697219, -2.371194218210151, 0.2470775524208056, 3.765986912471248, 2.564693663928388, -1.031587962897984 },
            { 0.2686829707914323, 0.3585999529709629, -0.1736258974466617, 0.2595686580125845, -0.8031184457735352, -0.84503481801564, 1.474935618452565, -1.257183724199307, -1.040954872508388, -0.9879160143396674, 0.1736258974466713, -1.879664867675789, 0.7283473563270753, 3.723738185957697 },
            { -0.01120298907476815, 0.01022488612900974, -0.01713324338635649, 0.05210906882037736, -0.1958177397495689, 0.03984355503604561, -0.002875468975933437, -0.03598998311434171, 0.1981645662194834, -0.0520471227218384, 0.01713324338636561, -4.538101711775523, -6.194609854764943e-5, 4.535754885305597 },
            { -0.3022873003764528, -0.3569762729465331, 0.1601400781900943, -0.6422567727167322, 1.575903838228306, 1.377626670672786, -2.692023408568552, 1.973660311218763, 0.4864896951260721, 0.2202893096878256, -0.1601400781900841, -3.612825860832497, 0.4219674630288927, 1.550432327478111 },
            { -0.315178069907573, 0.5228639416176886, 0.2542448049332265, -1.171658494969083, 2.903438517912311, 1.505464639164296, -2.91659133884278, 1.203440827968376, 0.215673969623293, 0.08908162017285945, -0.2542448049332131, -1.160344519688391, 1.082576874796201, -1.958767967847213 },
            { 0.07078628460558456, 3.135194050808043, 0.2119217391524031, -1.053176170699063, 2.610123916287852, -0.4360383367152212, 1.310273407995779, -4.08021540669418, -0.04716829097963843, -0.05704702916567239, -0.2119217391523839, 0.4048915582921009, 1.110223199864697, -2.967847183600306 },
            { 0.645338449451053, 6.405996726093939, 0.08682218138123687, -0.4489269841075334, 1.111958732786864, -3.446421647498835, 7.876378550827186, -11.48129207887333, -0.0680153083828543, -0.0533010765218026, -0.08682218138120956, 0.4256317452593437, 0.5022280606292746, -1.469575169663333 },
            { 0.08599288454202192, -0.754162113753288, 0.6668616942446794, -2.641770755171752, 2.461880847626117, -0.2602556976600618, -0.6853133837359473, 1.613738310607291, -0.146907786796956, -6.800877578116131, -0.6668616942446652, 3.775348950085792, 9.442648333287867, -6.09032201091497 },
            { -0.01334115788729341, -0.02841055147482174, 0.2486721097505815, -0.6667577330308725, 0.2990265097778454, -0.1746837929887251, 0.2627841557780399, -0.04634865342718375, 0.4262276278593091, -4.87048283575094, -0.2486721097505696, -0.002835181083664096, 5.537240568781805, -0.7224189565535122 },
            { -0.1739198856417217, 0.3585999529709631, -0.1495971096444872, 1.142142111585774, -1.1639462561337, 0.2604204349099559, 0.4512554115999602, -0.8963559138391424, 0.941592703953093, -2.503831946565821, 0.1495971096444966, -3.642491387056527, 1.361689834980043, 3.864844939237112 },
            { -0.324111023426189, 0.01022488612900987, -0.2475799162497422, 1.428827968246143, -0.2837954056036489, 0.972718020967831, -0.7108195664103758, 0.05198768273973775, 0.9890700242766052, -0.7604912192909268, 0.2475799162497522, -4.572254701987244, -0.6683367489552244, 3.866980083314273 },
            { -0.3415624616305095, -0.3569762729465328, -0.05069083715135553, 0.2767632454135731, 2.283931320698115, 1.325382198879604, -1.892476293051503, 1.265632828748953, 0.5751993514282759, -0.03997610070177332, 0.05069083715136724, -2.690995865957157, -0.2367871447118151, -0.1681348061692438 },
            { -0.1278107493943296, 0.5228639416176892, 0.1920060027088406, -1.025792320322364, 4.20790533528769, 0.5438424735369902, -0.837869676353341, -0.1010259894070014, 0.06891753248420293, -0.01376806542568235, -0.192006002708825, -0.09346706278851957, 1.039560385748021, -4.183355804983374 },
            { 0.2935376740276885, 3.135194050808044, 0.2486791068366039, -1.31478922912767, 3.782809343249656, -1.504245010033428, 3.328414118853684, -5.252900833655982, -0.1713371581617614, -0.1188721837214555, -0.2486791068365825, 1.112902650941719, 1.433661412849084, -4.724374836029606 },
            { 0.7484073591425991, 6.405996726093939, 0.1193222169731856, -0.6276394806833263, 1.611543366751887, -3.934840111019632, 8.761312738621459, -11.98087671283836, -0.1111771288093557, -0.08070813019490231, -0.119322216973156, 0.6754306229393028, 0.7083476108781657, -2.175796860881814 },
            { -0.3511544884193539, -0.7541621137532897, 3.976699573067303, -5.132922128456086, 3.173541560762386, 0.0918387813925976, 0.1114002233090425, 0.902077597471024, 1.970215019510654, -5.171015132639735, -3.976699573067288, -0.747872335597437, 10.30393726109582, -4.395884244675631 },
            { -0.3585318964657856, -0.02841055147482235, 2.530452022550688, -1.32387035206418, 0.3854666879856359, 0.3197467569808135, 0.1999845225947898, -0.1327888316349746, 1.743111142013526, -3.560395698526555, -2.530452022550675, -2.126071125662238, 4.884266050590735, -0.002506704336953769 },
            { -0.3424285203778157, 0.3585999529709631, 0.8868988691029904, 2.393004089206429, -1.500410477580945, 0.6191436679349769, -0.07542340813620585, -0.5598916923918991, 1.287768160856374, -1.645002789985532, -0.8868988691029789, -2.928019464628085, -0.748001299220898, 3.140661781352627 },
            { -0.260821017516271, 0.01022488612901024, -0.09800416443311058, 3.468580640727417, -0.3658326987291198, 0.7315417400184867, -0.6149705844964179, 0.1340249758652078, 0.6519699906021693, -0.3371054397097782, 0.098004164433122, -2.017515720792112, -3.131475201017645, 1.731378428919042 },
            { -0.07727932345976773, -0.3569762729465323, -0.2196033615209383, 1.808312003500102, 2.944151815938404, 0.3011767261409512, -0.4723334632433033, 0.6054123335086646, 0.02842363847303037, 0.07360394971314604, 0.2196033615209518, 0.1472509396525313, -1.881915953213265, -3.119826394063976 },
            { 0.210814246332098, 0.5228639416176899, 0.08195440796202524, -0.5142265146837174, 5.424292763057936, -0.8923073329391962, 1.476042562166663, -1.317413417177245, -0.3437324144002629, -0.04979470901446183, -0.0819544079620073, 1.928273500484353, 0.5640212236981512, -7.008833849142029 },
            { 0.5522760901743133, 3.135194050808044, 0.2562371705864877, -1.440554167204562, 4.876313440928246, -2.669536056744477, 5.328470847096696, -6.346404931334568, -0.3624595894421804, -0.1789301048377797, -0.2562371705864647, 2.084812774709671, 1.619484272042298, -6.59866662619573 },
            { 0.8500304373238443, 6.40599672609394, 0.1461678872148471, -0.7814462001743756, 2.07739536066074, -4.408632276419489, 9.599333819748924, -12.44672870674721, -0.1589917309658709, -0.1076709359779696, -0.1461678872148185, 0.9416075928233796, 0.8891171361522829, -2.86001122251823 },
            { -0.02843861093262257, -0.7541621137532903, 9.102770001582734, -7.657683966642507, 3.737577582644356, 0.252080298484203, 0.192478850612682, 0.3380415755890511, -0.1930121279830428, 1.795566565882669, -9.102770001582721, -1.59236442086849, 5.862117400759842, -1.952201033792864 },
            { 0.02107594992625039, -0.02841055147482263, 6.23833631245057, -1.992619424180586, 0.4539759837035731, 0.2063667352104973, 0.002265993691011436, -0.2012981273529111, -0.4189918790624997, 1.92998376605732, -6.238336312450558, -0.8989450013243397, 0.06263565812327337, 0.863960896683224 },
            { 0.1129686446927445, 0.3585999529709631, 2.825121781191872, 3.677720533054388, -1.767079604410178, 0.02117417924091763, -0.1995202113419363, -0.2932225655626648, -0.7325021725320612, 1.858093290421226, -2.82512178119186, 0.519539636231801, -5.535813823475608, 1.980042140710399 },
            { 0.248081644543387, 0.01022488612901054, 0.4857241809879025, 5.60347553879375, -0.4308524301915128, -0.436609213930812, -0.02074202406916847, 0.199044707327602, -0.9978658586063746, 1.387556092860118, -0.4857241809878892, 2.426463318372404, -6.991031631653876, -0.9977450295745417 },
            { 0.4202319271475166, -0.356976272946532, -0.2527325732825308, 3.484613809522331, 3.467418219192807, -1.261073699213846, 1.115672114758613, 0.08214593025426375, -1.081775612699643, 0.6531627385169416, 0.2527325732825462, 3.998491171594945, -4.137776548039291, -6.384133778088124 },
            { 0.6120702361663553, 0.5228639416176906, -0.02041869299491733, 0.1486751485749032, 6.388356555202948, -2.42087447236198, 3.567417503900201, -2.281477209322255, -0.9213818944189869, 0.024225680213062, 0.02041869299493646, 4.296135793350227, -0.1729008287879955, -9.763110454134191 },
            { 0.7949390060858691, 3.135194050808045, 0.2465266053156852, -1.459211256805148, 5.742984439876825, -3.711718696792007, 6.994661570181245, -7.213075930283145, -0.573428157356926, -0.2203350181053934, -0.2465266053156605, 3.076643977159806, 1.679546274910497, -8.246200259679696 },
            { 0.9344301583008657, 6.405996726093941, 0.1651501454708488, -0.8945461822059517, 2.446612461703415, -4.796801031943447, 10.27231995533853, -12.81594580778988, -0.2023072288699785, -0.1297729007948832, -0.1651501454708199, 1.175592143242848, 1.024319083000772, -3.419897376076266 },
            { 0.7319093000045127, -0.7541621137532899, 13.54634079824022, -9.41679187699819, 4.077960776380396, 0.01865673065321416, 0.005937701242579863, -0.002341618146989077, -3.979765018699925, 9.265542342319902, -13.5463407982402, -0.09164378361342318, 0.1512495346783005, -0.006551974067098509 },
            { 0.7507602243411217, -0.02841055147482241, 9.509753913864555, -2.459492093537, 0.4953198198636637, -0.299357489704583, -0.1803502196486853, -0.2426419635130022, -3.758763631456009, 7.811488845449946, -9.509753913864543, 1.749994032212967, -5.351996751912931, 1.513449779379324 },
            { 0.7827198075820644, 0.3585999529709634, 4.615533370362147, 4.578517021761495, -1.928008491111549, -0.860114899735132, -0.1489111819565772, -0.1322936788612921, -3.36228576124909, 5.608537305419208, -4.615533370362133, 4.261657629742665, -10.1870543271807, 1.02863662261793 },
            { 0.8244834974539215, 0.01022488612901076, 1.11003645335652, 7.113571554977906, -0.4700903919393884, -1.632587178001984, 0.5595961253435955, 0.2382826690754793, -2.804131127873292, 3.241731781585117, -1.110036453356505, 6.362400714984109, -10.35530333656303, -3.08817919517146 },
            { 0.8714376996474733, -0.3569762729465317, -0.2018937394202294, 4.69408146989465, 3.783197854898018, -2.552682686683614, 2.271854965433635, -0.233633705450946, -2.124525340791029, 1.295545527970673, 0.2018937394202444, 7.09111177502846, -5.989626997865341, -8.749784289135466 },
            { 0.9180232810438368, 0.5228639416176908, -0.08172576279873511, 0.658871018428124, 6.970147610747036, -3.517284182548346, 4.939665224753172, -2.863268264866342, -1.398061286707407, 0.1336449578201826, 0.08172576279875546, 6.073467720800755, -0.7925159762483379, -11.64555404484039 },
            { 0.9583528073443071, 3.135194050808046, 0.2348358325792297, -1.435806809817537, 6.266001110968539, -4.392288453977501, 8.034834197200015, -7.736092601374857, -0.7288565908661573, -0.2400111585910567, -0.2348358325792041, 3.772632813583706, 1.675817968408548, -9.30977733368608 },
            { 0.9870399156977757, 6.405996726093941, 0.175649984460561, -0.9590338319723806, 2.669426769937735, -5.036494318944971, 10.68221779317747, -13.0387601160242, -0.2308444428253854, -0.1433456052466754, -0.17564998446053, 1.32672523703644, 1.102379437218993, -3.76530756414877 } } };
    alignas(32) static const double FE11_C0_D10_Q64[1][64][14] =
        { { { -6.702492895031698, -0.7319093000045385, 0.07350011300962317, 0.05575495282155085, 0.08495001766034843, -1.108632985913928, 0.4427283147367624, -0.08495001766034838, 12.33032733404384, -8.783533314044782, 3.887608175037174, 1.487190771630273, -0.452057898725971, -0.4984832675583136 },
            { -4.130664483955384, -0.7507602243411432, 0.3854149306431309, 0.1983897778578434, 0.2526757965511314, -4.553956795404795, 1.420125987194856, -0.2526757965511311, 8.610077052377468, -7.401358534598474, 3.672706190517531, 6.346705766035391, -2.178163901273727, -1.618515765052701 },
            { -1.314398438452776, -0.782719807582079, 0.9356891921264788, 0.107110451576834, 0.09323746806561845, -6.848596659495679, 0.6315907120309852, -0.09323746806561789, 4.117009725252182, -5.306602948075113, 3.286711468857785, 10.43469872407632, -4.521791256707119, -0.7387011636078216 },
            { 0.2077514281485901, -0.8244834974539312, 1.694202062662071, -0.6532193312918803, -0.247805422489294, -5.371447949417236, -2.847851403744721, 0.2478054224892949, 0.9299397978662831, -3.055723971774174, 2.742516243213229, 10.13203120560202, -6.454785318846853, 3.501070735036598 },
            { 0.2208119589055904, -0.8714376996474794, 2.598266466802988, -2.388890901290984, 0.3102710094793665, -1.221053186244256, -6.607897075607885, -0.3102710094793654, -0.2221189928552929, -1.206196827074488, 2.078941560671668, 5.686211259508624, -7.063424540067354, 8.996787976898865 },
            { -0.2776089498223087, -0.9180232810438406, 3.546627172533868, -5.044411187357767, 3.004464507319322, 1.813338036409957, -6.601421387262441, -3.004464507319322, -0.067245694575399, -0.1058403712803461, 1.368718296721894, 0.6365611357922172, -5.99652634473604, 11.6458325746202 },
            { -0.2351458007909017, -0.9583528073443131, 4.407314017843712, -8.101083092992427, 7.863024749943838, 0.9923765325127065, -1.09443016631624, -7.863024749943838, 0.2381603280073044, 0.241507253127944, 0.7138310269999659, -1.691810538028182, -3.707880012328233, 9.195513259308662 },
            { 0.4466595727066636, -0.9870399156977825, 5.041195672223738, -10.70568244717873, 13.09283544562522, -2.654439082662064, 7.008575307060767, -13.09283544562523, 0.1731876910872696, 0.1410495623572016, 0.2261430895466476, -1.085792049415899, -1.300964540145774, 3.697107140117954 },
            { -3.881165331863511, 0.0284386109326101, 0.003889269190981981, 0.01328677714375431, 0.08495001766034727, -0.8626462933664563, 0.4002601390589689, -0.08495001766034721, 4.257802414852489, -0.3421182542294879, -0.06295743969209977, 0.9256065427166907, -0.06684951854121599, -0.4135469162027237 },
            { -2.195702538903284, -0.02107594992626245, 0.04687507247222153, 0.06050067240357671, 0.2526757965511313, -3.505140866784946, 1.28223688174059, -0.2526757965511313, 2.692565591965317, -0.6415371745155866, 0.1657500713798161, 3.910534050624782, -0.4522682563120591, -1.342737554144168 },
            { -0.4419604658421753, -0.1129686446927542, 0.2224122669592715, 0.04417696347170819, 0.09323746806561878, -5.127821952825133, 0.5686572239258567, -0.09323746806561864, 0.9138403632837401, -0.8478269790807087, 0.4889157263318962, 6.279872385568019, -1.374462699702159, -0.6128341873975658 },
            { 0.3416793456341741, -0.2480816445433943, 0.6577969863035866, -0.3549463566257394, -0.2478054224892937, -3.708478514764055, -2.549578429078583, 0.2478054224892942, -0.1509504882634264, -0.7193252990609693, 0.7766780862336149, 5.769687259937168, -2.7190057314767, 2.904524785704321 },
            { 0.1102983504746615, -0.4202319271475221, 1.443483378062632, -1.622411468169186, 0.310271009479367, -0.3009328809952891, -5.841417642486092, -0.3102710094793661, -0.278255857814322, -0.3111764993636835, 0.8993659338508654, 2.691187560270329, -3.833738057337671, 7.463829110655276 },
            { -0.3221937484597348, -0.6120702361663595, 2.550244555096624, -4.05224696464335, 3.004464507319323, 1.896438467926462, -5.60925716454803, -3.004464507319323, 0.05712350741687251, 0.08512866552487083, 0.7920118116843504, -0.5260223446780413, -3.920660678345042, 9.661504129191378 },
            { -0.1878495220181586, -0.7949390060858725, 3.783238772550875, -7.317673301814006, 7.863024749943839, 0.6964008079044164, -0.3110203751378213, -7.86302474994384, 0.2584724275768007, 0.2224080189291623, 0.5019080815980677, -1.723934334104439, -2.755705246350849, 7.628693676951825 },
            { 0.486342215432926, -0.9344301583008726, 4.820347634543529, -10.39070819278656, 13.09283544562522, -2.840269482322892, 7.323549561452936, -13.09283544562523, 0.1516594571518424, 0.1176678594461772, 0.1787606262699263, -0.9349792877744518, -1.045098864446182, 3.067158631333619 },
            { -0.9883599063437781, 0.3511544884193525, -0.04675661431403205, -0.05708561875210122, 0.0849500176603466, -0.5197347107793351, 0.3298877431631185, -0.08495001766034666, -2.834716428110611, 5.487219032624256, -2.015297186589218, 0.1891374940374263, 0.3773538310559407, -0.2728021244110173 },
            { -0.3130854122260187, 0.3585318964657834, -0.2296716823644331, -0.1679901107271543, 0.2526757965511311, -2.051622696830051, 1.053746098609859, -0.2526757965511313, -2.312389256614847, 4.10012898900499, -1.833186216629907, 0.7269509558783359, 1.554343423316147, -0.8857559878827042 },
            { 0.2661918638050497, 0.3424285203778121, -0.4605041294174285, -0.06010772192759251, 0.09323746806561933, -2.775419367965438, 0.464372538526553, -0.09323746806561953, -1.526993391575396, 2.364780706766456, -1.446407699373922, 0.892150819471926, 2.343772677910938, -0.4042648165989591 },
            { 0.2988067218574776, 0.2608210175162666, -0.50616644096617, 0.139310425617315, -0.2478054224892935, -1.506259161205451, -2.055321646835533, 0.2478054224892936, -0.7014232924788086, 1.019140842759546, -0.8773452896544817, 0.2012851255501985, 1.811140476621421, 1.91601122121822 },
            { -0.09266752798395383, 0.07727932345976342, -0.04466838980150012, -0.3523076020904774, 0.3102710094793671, 0.798368128899658, -4.571313776407386, -0.3102710094793669, -0.0615995083458634, 0.3619196876825299, -0.284931974812476, -0.9955662273837056, 0.2418664882855473, 4.923621378497865 },
            { -0.3580666001608297, -0.2108142463321017, 1.120491766746862, -2.408169432227281, 3.004464507319324, 1.812826141658177, -3.965179632131961, -3.004464507319324, 0.2549173593958298, 0.1984155065044978, 0.115547980592603, -1.78855048049124, -1.144767427913798, 6.37334906435924 },
            { -0.08998785659974629, -0.5522760901743182, 2.816374202602747, -6.019514784439266, 7.86302474994384, 0.1386839691884507, 0.987138142236919, -7.863024749943841, 0.2617882905489423, 0.1648542126411971, 0.2156214435839251, -1.575365226620641, -1.379692945170555, 5.032376642202347 },
            { 0.554621523835622, -0.8500304373238511, 4.46156805800576, -9.868776356221309, 13.09283544562522, -3.155381250023736, 7.845481398018181, -13.09283544562523, 0.1111956054101968, 0.07815735869840348, 0.1060559493796281, -0.6635353289105321, -0.6426514790714899, 2.023294958203125 },
            { 0.313268858675518, -0.08599288454201658, 0.004494189772060175, -0.1458765248386425, 0.08495001766034471, -0.2022253510375163, 0.241096837076575, -0.08495001766034482, -3.894302222797802, 3.264356953979377, 0.402669294684923, -0.3946304213601254, 0.5923615826255803, -0.09522031223793237 },
            { 0.3585742829570687, 0.01334115788729607, -0.07239375943207627, -0.4562836014962729, 0.2526757965511309, -0.7238814292694187, 0.7654526078407394, -0.2526757965511311, -2.692053982946622, 2.499288617540789, -0.1791500754385322, -1.771253656310575, 2.567528845012068, -0.309169006344465 },
            { 0.2686829707914326, 0.1739198856417221, -0.4340463323566212, -0.1916867535873642, 0.09323746806561964, -0.6954377083711525, 0.3327935068667804, -0.09323746806562005, -1.190551982152865, 1.515915932226155, -0.7679668065064441, -3.241354702655839, 4.370838743383612, -0.1411067532794136 },
            { -0.01120298907476616, 0.3241110234261874, -0.9898512643541874, 0.7629286352307624, -0.2478054224892935, 0.2874234712857868, -1.431703437222087, 0.2478054224892934, -0.04941535003025396, 0.7084440965690892, -0.9719367808902559, -3.869764962820298, 4.572192755888697, 0.6687748019913271 },
            { -0.3022873003764492, 0.3415624616305067, -1.165242120689507, 1.250219520334777, 0.3102710094793675, 1.428317507824139, -2.968786653982133, -0.3102710094793675, 0.4357988579747171, 0.2602654103895986, -0.7353394296183728, -3.376038716120681, 3.112963328986047, 1.718567133647357 },
            { -0.3151780699075679, 0.1278107493943259, -0.2895976686037597, -0.3337888186157397, 3.004464507319326, 1.313458636455453, -1.890799018520423, -3.004464507319326, 0.4076799723321307, 0.1028496855985403, -0.3231623374174292, -2.199904905436419, 1.176043937584726, 2.224587837136161 },
            { 0.07078628460558944, -0.2935376740276936, 1.716166749185839, -4.38159028955275, 7.863024749943842, -0.684717443551822, 2.625062637123433, -7.863024749943843, 0.2015108158569593, 0.06182515455578061, -0.04058458099063633, -1.028769854557005, -0.00267945107701073, 1.756527652429315 },
            { 0.6453384494510563, -0.7484073591426067, 4.021662292400885, -9.210239722729009, 13.09283544562522, -3.565743864472009, 8.50401803151048, -13.09283544562523, 0.05130690859032117, 0.02740705367309527, 0.02435494742813282, -0.2827158656188633, -0.1732025623100113, 0.7062216912185251 },
            { 0.08599288454202193, -0.3132688586755195, 0.2022253510375126, -0.2410968370765808, 0.08495001766034377, -0.004494189772059121, 0.1458765248386351, -0.08495001766034388, -0.4026692946849364, -3.264356953979366, 3.894302222797799, -0.5923615826255881, 0.3946304213601339, 0.09522031223794597 },
            { -0.01334115788729302, -0.3585742829570684, 0.7238814292694138, -0.7654526078407407, 0.2526757965511304, 0.07239375943207629, 0.4562836014962706, -0.2526757965511307, 0.1791500754385248, -2.499288617540783, 2.692053982946619, -2.567528845012074, 1.771253656310583, 0.3091690063444718 },
            { -0.173919885641721, -0.2686829707914316, 0.6954377083711463, -0.3327935068667798, 0.09323746806561964, 0.4340463323566212, 0.1916867535873651, -0.09323746806561997, 0.7679668065064404, -1.51591593222615, 1.190551982152862, -4.370838743383619, 3.24135470265585, 0.141106753279417 },
            { -0.3241110234261877, 0.01120298907476736, -0.2874234712857923, 1.431703437222087, -0.2478054224892934, 0.9898512643541888, -0.7629286352307617, 0.2478054224892933, 0.9719367808902561, -0.7084440965690862, 0.0494153500302506, -4.572192755888709, 3.869764962820311, -0.6687748019913228 },
            { -0.3415624616305075, 0.3022873003764502, -1.428317507824142, 2.968786653982132, 0.3102710094793681, 1.16524212068951, -1.250219520334777, -0.310271009479368, 0.7353394296183742, -0.2602654103895978, -0.4357988579747192, -3.112963328986059, 3.37603871612069, -1.718567133647354 },
            { -0.1278107493943264, 0.3151780699075689, -1.313458636455453, 1.890799018520421, 3.004464507319328, 0.2895976686037628, 0.3337888186157383, -3.004464507319328, 0.3231623374174302, -0.102849685598541, -0.407679972332132, -1.176043937584734, 2.199904905436425, -2.22458783713616 },
            { 0.2935376740276922, -0.07078628460558989, 0.6847174435518308, -2.62506263712345, 7.863024749943845, -1.716166749185828, 4.381590289552733, -7.863024749943846, 0.0405845809906385, -0.06182515455578411, -0.2015108158569577, 0.002679451076999184, 1.028769854556999, -1.756527652429285 },
            { 0.7484073591426021, -0.6453384494510603, 3.565743864472035, -8.504018031510528, 13.09283544562522, -4.021662292400857, 9.210239722728963, -13.09283544562523, -0.02435494742812583, -0.0274070536731026, -0.05130690859031428, 0.1732025623099855, 0.2827158656188389, -0.7062216912184379 },
            { -0.3511544884193485, 0.9883599063437631, 0.5197347107793295, -0.329887743163123, 0.08495001766034205, 0.04675661431403988, 0.05708561875209373, -0.08495001766034199, 2.01529718658922, -5.487219032624285, 2.834716428110649, -0.3773538310559582, -0.1891374940374108, 0.2728021244110296 },
            { -0.3585318964657818, 0.3130854122260108, 2.051622696830041, -1.05374609860986, 0.2526757965511298, 0.2296716823644389, 0.1679901107271518, -0.2526757965511298, 1.83318621662991, -4.100128989005008, 2.312389256614868, -1.554343423316166, -0.7269509558783142, 0.885755987882709 },
            { -0.3424285203778137, -0.2661918638050517, 2.775419367965426, -0.464372538526553, 0.09323746806561944, 0.4605041294174352, 0.06010772192759228, -0.09323746806561933, 1.446407699373928, -2.364780706766467, 1.526993391575404, -2.343772677910966, -0.8921508194718956, 0.4042648165989616 },
            { -0.2608210175162703, -0.2988067218574765, 1.506259161205439, 2.055321646835532, -0.2478054224892933, 0.5061664409661797, -0.139310425617315, 0.2478054224892935, 0.877345289654491, -1.019140842759552, 0.7014232924788076, -1.811140476621459, -0.2012851255501592, -1.916011221218216 },
            { -0.07727932345976697, 0.09266752798395564, -0.7983681288996661, 4.571313776407384, 0.310271009479369, 0.04466838980150956, 0.3523076020904764, -0.3102710094793686, 0.2849319748124838, -0.3619196876825329, 0.06159950834585948, -0.2418664882855819, 0.9955662273837385, -4.923621378497861 },
            { 0.2108142463320999, 0.3580666001608309, -1.812826141658179, 3.96517963213196, 3.00446450731933, -1.120491766746855, 2.408169432227278, -3.00446450731933, -0.1155479805925983, -0.1984155065045003, -0.2549173593958334, 1.144767427913776, 1.78855048049126, -6.373349064359239 },
            { 0.5522760901743159, 0.08998785659974617, -0.1386839691884427, -0.987138142236935, 7.863024749943847, -2.816374202602734, 6.019514784439249, -7.863024749943849, -0.2156214435839205, -0.1648542126412008, -0.2617882905489417, 1.379692945170537, 1.57536522662064, -5.032376642202316 },
            { 0.8500304373238469, -0.5546215238356249, 3.155381250023759, -7.845481398018222, 13.09283544562523, -4.461568058005736, 9.868776356221266, -13.09283544562523, -0.1060559493796212, -0.07815735869841131, -0.1111956054101907, 0.6426514790714655, 0.6635353289105121, -2.023294958203047 },
            { -0.02843861093261074, 3.881165331863482, 0.8626462933664523, -0.4002601390589802, 0.08495001766034105, -0.003889269190973155, -0.01328677714375592, -0.08495001766034099, 0.06295743969212864, 0.3421182542294042, -4.257802414852403, 0.066849518541202, -0.9256065427166807, 0.4135469162027365 },
            { 0.02107594992625842, 2.195702538903266, 3.505140866784935, -1.282236881740594, 0.2526757965511295, -0.04687507247221326, -0.0605006724035787, -0.2526757965511292, -0.1657500713797901, 0.6415371745155265, -2.69256559196526, 0.4522682563120362, -3.910534050624758, 1.342737554144172 },
            { 0.1129686446927481, 0.4419604658421682, 5.127821952825118, -0.5686572239258569, 0.09323746806561958, -0.22241226695926, -0.04417696347171191, -0.09323746806561889, -0.4889157263318759, 0.8478269790806744, -0.913840363283715, 1.374462699702114, -6.279872385567971, 0.6128341873975673 },
            { 0.248081644543387, -0.3416793456341743, 3.708478514764039, 2.549578429078581, -0.2478054224892931, -0.6577969863035722, 0.3549463566257342, 0.2478054224892939, -0.7766780862335978, 0.7193252990609535, 0.1509504882634303, 2.719005731476643, -5.769687259937109, -2.904524785704317 },
            { 0.4202319271475161, -0.1102983504746602, 0.3009328809952794, 5.841417642486089, 0.31027100947937, -1.443483378062618, 1.622411468169183, -0.3102710094793694, -0.8993659338508532, 0.3111764993636775, 0.2782558578143187, 3.833738057337619, -2.691187560270279, -7.463829110655274 },
            { 0.6120702361663557, 0.322193748459736, -1.896438467926465, 5.609257164548025, 3.004464507319332, -2.550244555096613, 4.052246964643347, -3.004464507319332, -0.7920118116843429, -0.08512866552487433, -0.05712350741687627, 3.920660678345009, 0.5260223446780696, -9.661504129191375 },
            { 0.7949390060858708, 0.1878495220181587, -0.6964008079044088, 0.3110203751378062, 7.863024749943849, -3.783238772550864, 7.317673301813991, -7.86302474994385, -0.5019080815980621, -0.2224080189291671, -0.2584724275768021, 2.755705246350829, 1.723934334104445, -7.6286936769518 },
            { 0.9344301583008683, -0.4863422154329289, 2.840269482322913, -7.323549561452974, 13.09283544562523, -4.820347634543504, 10.39070819278651, -13.09283544562523, -0.1787606262699182, -0.117667859446185, -0.1516594571518376, 1.045098864446157, 0.934979287774435, -3.067158631333541 },
            { 0.7319093000045291, 6.702492895031652, 1.108632985913925, -0.4427283147367799, 0.0849500176603406, -0.07350011300961728, -0.05575495282154652, -0.08495001766034049, -3.887608175037116, 8.783533314044643, -12.3303273340437, 0.452057898725968, -1.487190771630271, 0.4984832675583268 },
            { 0.7507602243411329, 4.130664483955352, 4.553956795404778, -1.420125987194862, 0.2526757965511295, -0.3854149306431226, -0.1983897778578437, -0.2526757965511289, -3.672706190517481, 7.401358534598368, -8.61007705237737, 2.1781639012737, -6.346705766035355, 1.618515765052704 },
            { 0.7827198075820693, 1.314398438452764, 6.84859665949566, -0.6315907120309849, 0.09323746806561981, -0.9356891921264635, -0.1071104515768408, -0.09323746806561881, -3.286711468857753, 5.306602948075061, -4.117009725252141, 4.52179125670706, -10.43469872407625, 0.738701163607822 },
            { 0.8244834974539219, -0.2077514281485924, 5.371447949417217, 2.847851403744719, -0.2478054224892926, -1.694202062662053, 0.6532193312918707, 0.2478054224892938, -2.742516243213208, 3.05572397177415, -0.9299397978662737, 6.454785318846779, -10.13203120560194, -3.501070735036593 },
            { 0.8714376996474718, -0.2208119589055896, 1.221053186244245, 6.607897075607883, 0.3102710094793708, -2.598266466802971, 2.388890901290977, -0.3102710094793697, -2.078941560671654, 1.20619682707448, 0.2221189928552884, 7.063424540067289, -5.686211259508563, -8.996787976898862 },
            { 0.9180232810438359, 0.2776089498223093, -1.81333803640996, 6.601421387262437, 3.004464507319333, -3.546627172533855, 5.044411187357757, -3.004464507319333, -1.368718296721884, 0.1058403712803409, 0.06724569457539552, 5.996526344735996, -0.6365611357921814, -11.6458325746202 },
            { 0.9583528073443085, 0.2351458007909016, -0.9923765325126972, 1.094430166316219, 7.86302474994385, -4.407314017843694, 8.101083092992404, -7.863024749943851, -0.7138310269999575, -0.241507253127949, -0.2381603280073052, 3.707880012328202, 1.69181053802819, -9.195513259308624 },
            { 0.9870399156977783, -0.4466595727066662, 2.654439082662085, -7.008575307060807, 13.09283544562523, -5.041195672223712, 10.70568244717868, -13.09283544562523, -0.2261430895466392, -0.1410495623572097, -0.1731876910872645, 1.300964540145746, 1.085792049415882, -3.697107140117875 } } };
    alignas(32) static const double FE11_C0_Q64[1][64][15] =
        { { { 0.7203877476300805, -0.01683009633753823, -0.01555052728487197, 0.001638540860573356, 0.001187836798938191, 0.001656699514021018, 0.2408527899499789, -0.1813118934356486, 0.08178291404055221, 0.2641814190897578, -0.1973986453105343, 0.08872105540527626, 0.0304534696971368, -0.009848863066396589, -0.00992244755132482 },
            { 0.3343500075381369, -0.01574761163926432, -0.04160789551083606, 0.007859075993127494, 0.003881197314305689, 0.004558735020722141, 0.8684650376532987, -0.5291578650268064, 0.2250417961604044, 0.1715734106602965, -0.1528200185264241, 0.07664573079855576, 0.1203326940353094, -0.04356953678405702, -0.02980475768676867 },
            { 0.02318331535881883, -0.01387544081014667, -0.01248663026134355, 0.01619621168378331, 0.001790051745764361, 0.001454500913666737, 0.9891479382021032, -0.1960679230568822, 0.07180138714811241, 0.07200214295315967, -0.09373102108105709, 0.0581991246546325, 0.1713937653764224, -0.0772454474565525, -0.01176197537048077 },
            { -0.03729791763986167, -0.01136070135777223, 0.02342181492126352, 0.02291655742216736, -0.008597216644423034, -0.003090215874190408, 0.4128582608632284, 0.6532239005736473, -0.1525483994331869, 0.01384252303534849, -0.04266540975491324, 0.03792996917393888, 0.1336139466902942, -0.086809335687108, 0.04456222371156782 },
            { 0.01535487873875881, -0.008444049388708796, -0.0158869085152141, 0.02485166996408423, -0.02241243043302515, 0.002801856122784212, -0.110069778477085, 0.8989185554016403, 0.1383135303079139, -0.001823171333008442, -0.01215473004764175, 0.02032047262059228, 0.05499943255955145, -0.06769329503997024, 0.08292396751932876 },
            { 0.009579693053544664, -0.005460034082160442, -0.02765966895777363, 0.02092669400902656, -0.0294131916469228, 0.01711020343880111, -0.05828479073155238, 0.1850142865056205, 0.8446445992221232, -0.0004654221823125072, -0.0007792633492807038, 0.008249189815993638, 0.004549650316920076, -0.03570538678286331, 0.06769344137083699 },
            { -0.03572440956445318, -0.002806525896858253, 0.2076501838267035, 0.01285637945087875, -0.02349345501446697, 0.02253859295181853, 0.200933462410377, -0.509171697014143, 1.112616859227324, 0.0006731339922392947, 0.0006960416641334777, 0.002126115103101832, -0.004819714843319571, -0.01097798961312991, 0.02690302331979599 },
            { -0.0310132994081584, -0.0008804621427381601, 0.6722059573768325, 0.004491513286689619, -0.009521358739369101, 0.01160300673869952, 0.1678100309074461, -0.389151493856983, 0.5727820251602688, 0.0001556628403231938, 0.0001274878960777492, 0.0002056736039471527, -0.000977847169457785, -0.001181054791066866, 0.003344158297489241 },
            { 0.3012128211431642, -0.0416040690416377, -0.015550527284872, 0.004551117193571472, 0.003961832868328102, 0.008483035273648451, 0.1618464782341067, -0.1474418461679281, 0.07495657828092478, 0.9089947375889238, -0.5353995601051754, 0.2258575508917674, 0.1268057000007901, -0.0301073579871757, -0.04656649088843512 },
            { 0.1033913885414235, -0.04163408100502219, -0.04160789551083605, 0.02312695554864895, 0.01350420077085974, 0.02334274239638039, 0.569707379345283, -0.4287105630797107, 0.2062577887847461, 0.5763111446016674, -0.4307867536988804, 0.2067198203921123, 0.4991948504676527, -0.1389419144639061, -0.1398750630904185 },
            { -0.03120854940985769, -0.04080811574998081, -0.01248663026134354, 0.05220264088654336, 0.0066523347682362, 0.007447688884897233, 0.6054475530347065, -0.1574927040944364, 0.06580819917688194, 0.2256670899026932, -0.2797987373308695, 0.1719264336634219, 0.7049469556244492, -0.2631046817399428, -0.05519947735539852 },
            { -0.02256016234174757, -0.03794179717919894, 0.02342181492126354, 0.08226684695795362, -0.0344986519838968, -0.01582327395045725, 0.1806564460252665, 0.5145550473388389, -0.13981534135692, 0.03101524858869924, -0.1348621104630456, 0.1247972848520331, 0.5389259505571311, -0.3192698142517689, 0.2091325122858499 },
            { 0.02157237304413312, -0.03209318640635699, -0.0158869085152141, 0.09944732808762338, -0.09704079710896424, 0.01434674430704547, -0.1377864337697461, 0.6673049949980365, 0.1267686421236526, -0.01168620172742029, -0.03906742157036339, 0.07452783724999956, 0.2090594325884768, -0.2686322978997734, 0.389165894598872 },
            { 0.002513213321155233, -0.02331376501147442, -0.02765966895777362, 0.0922635401725182, -0.1361425442119034, 0.08761181981538528, -0.01456210633545081, 0.04174872739178917, 0.7741429828455391, -0.0005954201979017186, -0.000813905413033016, 0.03333404055703852, 0.005256825038641624, -0.151472092064178, 0.3176883530496488 },
            { -0.03823079082074581, -0.01314758470049433, 0.2076501838267035, 0.06119499011817717, -0.1145477444641858, 0.1154075783873561, 0.2109364820449402, -0.5174714779518541, 1.019747873791786, 0.003618332566960544, 0.003449030628928562, 0.00927536762351417, -0.02508135727647777, -0.04905797748183335, 0.1262570937072258 },
            { -0.02931018037987245, -0.004388275604951399, 0.6722059573768325, 0.02249562459236837, -0.04803893035057882, 0.05941253354138354, 0.157778841261754, -0.3629840486581826, 0.5249724983575849, 0.0007494166254438592, 0.0005999736713814888, 0.0009441284774500819, -0.004670327645187267, -0.005461495975323916, 0.01569428470989853 },
            { -0.0007910783275319327, -0.005826692039548999, -0.01555052728487199, 0.0008015571053159726, 0.001045779063831909, 0.0197946961803756, 0.07070538097569332, -0.09882981827827987, 0.06364491737419774, 0.9266338256012627, -0.09473032757965791, 0.03377575282251791, 0.198336926938653, -0.006747927578369499, -0.09226246497358744 },
            { -0.03599084487269127, -0.01203473370362272, -0.04160789551083604, 0.008225980795809988, 0.006883573531768244, 0.05446900535571985, 0.2310900083166599, -0.2848297056581006, 0.1751315258254067, 0.5454863768117781, -0.1458910020769369, 0.06243172267277332, 0.7739069751144807, -0.06013569332927235, -0.277135293272937 },
            { -0.03341415004599769, -0.02235260520725511, -0.01248663026134352, 0.03399779827171863, 0.005803911409493309, 0.01737877233405571, 0.1900699480151665, -0.1024767057558777, 0.05587711572772349, 0.1653113694445722, -0.1588390003025993, 0.09507250718668697, 1.07033252558048, -0.1949078040616093, -0.1093670523352143 },
            { 0.006638093546302039, -0.03386269975144906, 0.02342181492126355, 0.08382432282012851, -0.0436788442948982, -0.03692273936442544, -0.03645090101578284, 0.3185122632251702, -0.1187158759429518, -0.01460251427770308, -0.1056947170091556, 0.1079703009487458, 0.778432535171098, -0.3432265276868617, 0.4143554887105201 },
            { 0.02212963791444543, -0.04117618737767966, -0.01588690851521409, 0.1398449295133448, -0.157919107269212, 0.03347733866174955, -0.1197248286392922, 0.3462925013822242, 0.1076380477689486, -0.02369456339872505, -0.03299239063028432, 0.08898690408223568, 0.2531547301814752, -0.3711868020489472, 0.7710566983749318 },
            { -0.01088395040638437, -0.03890290594918511, -0.02765966895777361, 0.1627354889966365, -0.2617459001435594, 0.204437362230779, 0.05844785480139474, -0.1443973843977032, 0.6573174404301454, 0.005576548814646835, 0.005412227544688534, 0.04992224325201872, -0.04242649700259984, -0.2472706799839004, 0.6294378207707971 },
            { -0.04099040738645698, -0.02627490376853928, 0.2076501838267035, 0.1256396723496864, -0.2450608340078543, 0.2692972358828885, 0.2192451693538352, -0.5108552243526102, 0.8658582162962536, 0.008775752838611393, 0.007284434425514095, 0.01616947918903391, -0.05777766998333177, -0.08911503431538356, 0.2501539296516504 },
            { -0.02616239745813675, -0.009785329000054653, 0.6722059573768325, 0.05057304827768067, -0.1093329161925158, 0.1386358788830364, 0.1396438362720536, -0.317090957616473, 0.445749153015932, 0.00154772536420119, 0.001192850764343237, 0.001802213119098568, -0.009520093945778824, -0.0105541483703441, 0.03109517951012569 },
            { -0.02814212408026887, 0.02231369232969017, -0.01555052728487197, -0.004547417908210463, -0.01600381723380556, 0.03406694893610746, 0.01185674433869728, -0.05086492978708573, 0.04937266461846571, 0.2674271755435484, 0.746110465066622, -0.1486477283825495, 0.1756784259749429, 0.08010818503586231, -0.1231777571671439 },
            { -0.01319954290127987, 0.02341079380907039, -0.04160789551083603, -0.02256401351811787, -0.04163125949833234, 0.09374191991355266, 0.02270963424647652, -0.1434524223224227, 0.1358586112675739, 0.09225656479628841, 0.4443822529505851, -0.1328485498233634, 0.6708041876441733, 0.2821374625251461, -0.3699977435785141 },
            { 0.01066226165214465, 0.01863074293826469, -0.01248663026134351, -0.03720950206549631, -0.01111562705244917, 0.02990911021223263, -0.03205992908989158, -0.04891047266834637, 0.04334677784954648, -0.04798839492980846, 0.1451934554640345, -0.08071994404922826, 0.8791841016550781, 0.2895777973060658, -0.1460137469608029 },
            { 0.02341866987048187, 0.002114117082892099, 0.02342181492126354, -0.006372404299019668, 0.004785063160893631, -0.06354455077497531, -0.09208293415811264, 0.1312061840459501, -0.0920940645324019, -0.06348672438625028, 0.004769775768754155, -0.006367374879137702, 0.5518658562924553, 0.02916891145325879, 0.5531976604339487 },
            { 0.006094040827342841, -0.02259206585043822, -0.0158869085152141, 0.08730623833261836, -0.122992439315374, 0.0576149679850737, -0.02763596945646029, 0.05300027669972017, 0.08350041844562443, -0.009412903140750512, -0.003932715862820195, 0.04309704461665816, 0.0666815206559957, -0.2242637605255732, 1.029422255103598 },
            { -0.02785435031988258, -0.04022752957765508, -0.02765966895777361, 0.1813211005030175, -0.3290075817754157, 0.3518395592579542, 0.1369339276115992, -0.2880476283509191, 0.5099152434029701, 0.02248497434513975, 0.01357084976727366, 0.04315021904090885, -0.1456553870598155, -0.2411134742432701, 0.8403497463558693 },
            { -0.0413165406002055, -0.03661254047476172, 0.2076501838267035, 0.1813273908851, -0.3734816511685458, 0.4634643088158368, 0.2127782349780094, -0.4662559464360858, 0.6716911433633053, 0.01465770413196084, 0.01013252643912385, 0.01810320580204568, -0.09075508495581552, -0.1053584035024875, 0.3339754688958174 },
            { -0.02158507032705626, -0.01588361297765804, 0.6722059573768325, 0.08294696401927315, -0.1821631319709027, 0.2385942862463853, 0.1139963944756874, -0.2546801096778876, 0.3457907456525829, 0.002174441075830036, 0.001596271781671356, 0.002293033236664466, -0.01315942168821388, -0.01364129457313545, 0.04151454734992738 },
            { 0.02231369232969029, -0.02814212408026898, -0.01555052728487199, 0.01185674433869728, -0.05086492978708583, 0.0493726646184658, -0.004547417908210324, -0.01600381723380566, 0.03406694893610752, -0.1486477283825494, 0.7461104650666218, 0.2674271755435481, 0.08010818503586267, 0.175678425974943, -0.1231777571671438 },
            { 0.02341079380907053, -0.01319954290127996, -0.04160789551083601, 0.02270963424647639, -0.1434524223224229, 0.1358586112675739, -0.02256401351811782, -0.04163125949833207, 0.09374191991355257, -0.1328485498233634, 0.444382252950585, 0.09225656479628853, 0.2821374625251463, 0.6708041876441732, -0.369997743578514 },
            { 0.0186307429382648, 0.01066226165214458, -0.0124866302613435, -0.03205992908989183, -0.04891047266834642, 0.04334677784954642, -0.03720950206549624, -0.01111562705244883, 0.02990911021223264, -0.08071994404922823, 0.1451934554640344, -0.04798839492980844, 0.289577797306066, 0.8791841016550779, -0.1460137469608028 },
            { 0.002114117082892217, 0.02341866987048178, 0.02342181492126354, -0.09208293415811281, 0.13120618404595, -0.09209406453240204, -0.006372404299019654, 0.004785063160893874, -0.0635445507749752, -0.006367374879137742, 0.004769775768754185, -0.06348672438625025, 0.02916891145325912, 0.5518658562924549, 0.5531976604339488 },
            { -0.02259206585043817, 0.006094040827342789, -0.01588690851521409, -0.02763596945646033, 0.05300027669972018, 0.08350041844562431, 0.08730623833261836, -0.122992439315374, 0.05761496798507394, 0.04309704461665812, -0.003932715862820192, -0.009412903140750493, -0.2242637605255731, 0.06668152065599563, 1.029422255103598 },
            { -0.04022752957765512, -0.02785435031988254, -0.02765966895777358, 0.1369339276115992, -0.2880476283509191, 0.5099152434029702, 0.1813211005030174, -0.3290075817754157, 0.3518395592579541, 0.04315021904090887, 0.01357084976727369, 0.02248497434513971, -0.2411134742432701, -0.1456553870598155, 0.8403497463558692 },
            { -0.03661254047476178, -0.04131654060020543, 0.2076501838267035, 0.2127782349780095, -0.4662559464360859, 0.6716911433633052, 0.1813273908850999, -0.3734816511685458, 0.4634643088158369, 0.01810320580204568, 0.01013252643912385, 0.01465770413196079, -0.1053584035024874, -0.09075508495581568, 0.3339754688958174 },
            { -0.01588361297765814, -0.02158507032705616, 0.6722059573768325, 0.113996394475687, -0.2546801096778868, 0.3457907456525815, 0.08294696401927365, -0.1821631319709038, 0.2385942862463868, 0.002293033236664466, 0.001596271781671363, 0.002174441075830008, -0.01364129457313532, -0.01315942168821402, 0.04151454734992749 },
            { -0.005826692039548793, -0.0007910783275320681, -0.01555052728487197, 0.07070538097569293, -0.09882981827827975, 0.06364491737419761, 0.0008015571053159726, 0.001045779063831992, 0.01979469618037558, 0.03377575282251788, -0.09473032757965731, 0.9266338256012621, -0.006747927578369228, 0.1983369269386525, -0.09226246497358723 },
            { -0.01203473370362259, -0.03599084487269123, -0.041607895510836, 0.2310900083166595, -0.2848297056581004, 0.1751315258254065, 0.008225980795810026, 0.006883573531768501, 0.05446900535571986, 0.06243172267277335, -0.1458910020769368, 0.5454863768117778, -0.06013569332927199, 0.7739069751144805, -0.2771352932729368 },
            { -0.02235260520725498, -0.03341415004599768, -0.01248663026134348, 0.1900699480151661, -0.1024767057558775, 0.05587711572772332, 0.0339977982717186, 0.005803911409493746, 0.01737877233405574, 0.09507250718668707, -0.1588390003025994, 0.1653113694445721, -0.1949078040616091, 1.07033252558048, -0.109367052335214 },
            { -0.03386269975144895, 0.006638093546301988, 0.02342181492126354, -0.03645090101578322, 0.3185122632251702, -0.1187158759429519, 0.08382432282012853, -0.04367884429489796, -0.03692273936442528, 0.1079703009487458, -0.1056947170091555, -0.01460251427770311, -0.3432265276868616, 0.7784325351710978, 0.4143554887105203 },
            { -0.04117618737767963, 0.02212963791444536, -0.01588690851521409, -0.1197248286392923, 0.3462925013822241, 0.1076380477689485, 0.1398449295133448, -0.1579191072692119, 0.03347733866174973, 0.08898690408223568, -0.03299239063028432, -0.02369456339872508, -0.3711868020489471, 0.2531547301814751, 0.771056698374932 },
            { -0.03890290594918511, -0.01088395040638432, -0.02765966895777358, 0.05844785480139474, -0.1443973843977031, 0.6573174404301455, 0.1627354889966364, -0.2617459001435593, 0.2044373622307789, 0.04992224325201869, 0.005412227544688555, 0.005576548814646747, -0.2472706799839002, -0.0424264970025998, 0.6294378207707967 },
            { -0.02627490376853929, -0.04099040738645689, 0.2076501838267036, 0.2192451693538353, -0.5108552243526104, 0.8658582162962536, 0.1256396723496864, -0.2450608340078543, 0.2692972358828885, 0.01616947918903387, 0.007284434425514126, 0.008775752838611293, -0.08911503431538344, -0.05777766998333193, 0.2501539296516503 },
            { -0.009785329000054681, -0.02616239745813668, 0.6722059573768325, 0.1396438362720533, -0.3170909576164724, 0.4457491530159312, 0.05057304827768089, -0.1093329161925163, 0.1386358788830371, 0.001802213119098568, 0.001192850764343258, 0.0015477253642011, -0.0105541483703441, -0.009520093945779018, 0.0310951795101258 },
            { -0.04160406904163759, 0.3012128211431642, -0.01555052728487195, 0.1618464782341066, -0.1474418461679281, 0.0749565782809247, 0.004551117193571638, 0.003961832868328186, 0.008483035273648465, 0.2258575508917676, -0.5353995601051755, 0.9089947375889235, -0.03010735798717556, 0.1268057000007898, -0.04656649088843506 },
            { -0.04163408100502208, 0.1033913885414236, -0.04160789551083598, 0.5697073793452827, -0.4287105630797105, 0.206257788784746, 0.02312695554864895, 0.01350420077085995, 0.02334274239638041, 0.2067198203921124, -0.4307867536988805, 0.5763111446016673, -0.138941914463906, 0.4991948504676522, -0.1398750630904182 },
            { -0.04080811574998071, -0.03120854940985768, -0.01248663026134346, 0.605447553034706, -0.1574927040944361, 0.06580819917688177, 0.05220264088654336, 0.006652334768236484, 0.007447688884897316, 0.1719264336634219, -0.2797987373308695, 0.2256670899026931, -0.2631046817399427, 0.704946955624449, -0.05519947735539819 },
            { -0.03794179717919888, -0.02256016234174762, 0.02342181492126356, 0.1806564460252661, 0.5145550473388392, -0.1398153413569201, 0.08226684695795367, -0.03449865198389662, -0.01582327395045703, 0.1247972848520331, -0.1348621104630456, 0.03101524858869913, -0.3192698142517689, 0.5389259505571307, 0.2091325122858501 },
            { -0.03209318640635692, 0.02157237304413301, -0.01588690851521409, -0.1377864337697462, 0.6673049949980366, 0.1267686421236526, 0.09944732808762342, -0.09704079710896418, 0.01434674430704565, 0.07452783724999949, -0.03906742157036333, -0.01168620172742031, -0.2686322978997733, 0.2090594325884764, 0.3891658945988715 },
            { -0.02331376501147438, 0.002513213321155243, -0.02765966895777357, -0.01456210633545086, 0.04174872739178931, 0.7741429828455392, 0.09226354017251814, -0.1361425442119031, 0.08761181981538516, 0.03333404055703842, -0.0008139054130329674, -0.000595420197901847, -0.1514720920641778, 0.005256825038641555, 0.317688353049648 },
            { -0.01314758470049431, -0.03823079082074571, 0.2076501838267036, 0.2109364820449403, -0.5174714779518543, 1.019747873791786, 0.061194990118177, -0.1145477444641853, 0.1154075783873556, 0.009275367623514072, 0.003449030628928624, 0.003618332566960416, -0.04905797748183309, -0.02508135727647779, 0.1262570937072254 },
            { -0.004388275604951426, -0.02931018037987237, 0.6722059573768325, 0.1577788412617538, -0.3629840486581823, 0.5249724983575839, 0.02249562459236865, -0.04803893035057938, 0.05941253354138432, 0.0009441284774500749, 0.0005999736713814749, 0.000749416625443762, -0.005461495975323805, -0.004670327645187489, 0.01569428470989859 },
            { -0.01683009633753811, 0.7203877476300801, -0.01555052728487195, 0.2408527899499786, -0.1813118934356484, 0.0817829140405521, 0.001638540860573315, 0.001187836798938358, 0.001656699514021032, 0.08872105540527657, -0.1973986453105352, 0.2641814190897586, -0.009848863066396603, 0.03045346969713682, -0.009922447551324709 },
            { -0.01574761163926427, 0.3343500075381365, -0.04160789551083596, 0.868465037653298, -0.5291578650268061, 0.2250417961604043, 0.007859075993127542, 0.003881197314305793, 0.004558735020722182, 0.07664573079855606, -0.1528200185264249, 0.1715734106602971, -0.04356953678405701, 0.1203326940353096, -0.02980475768676854 },
            { -0.01387544081014665, 0.02318331535881881, -0.01248663026134344, 0.9891479382021027, -0.196067923056882, 0.07180138714811227, 0.01619621168378331, 0.00179005174576443, 0.001454500913666876, 0.05819912465463243, -0.09373102108105709, 0.07200214295315956, -0.07724544745655247, 0.1713937653764218, -0.01176197537048036 },
            { -0.01136070135777219, -0.03729791763986175, 0.02342181492126357, 0.4128582608632281, 0.6532239005736475, -0.152548399433187, 0.02291655742216751, -0.008597216644423061, -0.003090215874190103, 0.03792996917393879, -0.04266540975491322, 0.01384252303534834, -0.08680933568710794, 0.1336139466902938, 0.04456222371156809 },
            { -0.008444049388708704, 0.01535487873875868, -0.01588690851521408, -0.110069778477085, 0.8989185554016409, 0.1383135303079138, 0.0248516699640842, -0.02241243043302514, 0.002801856122784482, 0.02032047262059212, -0.01215473004764167, -0.001823171333008538, -0.06769329503996994, 0.05499943255955105, 0.08292396751932812 },
            { -0.005460034082160349, 0.009579693053544678, -0.02765966895777357, -0.05828479073155237, 0.1850142865056206, 0.8446445992221235, 0.02092669400902653, -0.02941319164692269, 0.01711020343880101, 0.008249189815993504, -0.0007792633492807073, -0.0004654221823127778, -0.03570538678286294, 0.004549650316919909, 0.06769344137083633 },
            { -0.002806525896858298, -0.03572440956445309, 0.2076501838267036, 0.2009334624103772, -0.5091716970141432, 1.112616859227323, 0.01285637945087897, -0.02349345501446747, 0.02253859295181908, 0.002126115103101783, 0.0006960416641335263, 0.0006731339922391353, -0.01097798961313008, -0.004819714843319714, 0.02690302331979649 },
            { -0.0008804621427382156, -0.0310132994081583, 0.6722059573768325, 0.167810030907446, -0.3891514938569827, 0.5727820251602678, 0.004491513286690035, -0.009521358739369767, 0.01160300673870041, 0.0002056736039471735, 0.0001274878960777701, 0.0001556628403231175, -0.001181054791066671, -0.0009778471694579238, 0.003344158297489352 } } };
    alignas(32) static const double FE3_C0_D01_Q64[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q64[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q64[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q64[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q64[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q64[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q64[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q64[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q64[0][0][1];
    alignas(32) double sp[8];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = -1 * J_c1 / sp[2];
    sp[5] = J_c3 / sp[2];
    sp[6] = -1 * J_c2 / sp[2];
    sp[7] = std::abs(sp[2]);
    alignas(32) double BF0[15] = {};
    for (int iq = 0; iq < 64; ++iq)
    {
        // Quadrature loop body setup (num_points=64)
        // Unstructured varying computations for num_points=64
        const double w0_d1 = w[0][0] * FE11_C0_D01_Q64[0][iq][0] + w[0][2] * FE11_C0_D01_Q64[0][iq][1] + w[0][3] * FE11_C0_D01_Q64[0][iq][2] + w[0][4] * FE11_C0_D01_Q64[0][iq][3] + w[0][5] * FE11_C0_D01_Q64[0][iq][4] + w[0][6] * FE11_C0_D01_Q64[0][iq][5] + w[0][7] * FE11_C0_D01_Q64[0][iq][6] + w[0][8] * FE11_C0_D01_Q64[0][iq][7] + w[0][9] * FE11_C0_D01_Q64[0][iq][8] + w[0][10] * FE11_C0_D01_Q64[0][iq][9] + w[0][11] * FE11_C0_D01_Q64[0][iq][10] + w[0][12] * FE11_C0_D01_Q64[0][iq][11] + w[0][13] * FE11_C0_D01_Q64[0][iq][12] + w[0][14] * FE11_C0_D01_Q64[0][iq][13];
        const double w0_d0 = w[0][0] * FE11_C0_D10_Q64[0][iq][0] + w[0][1] * FE11_C0_D10_Q64[0][iq][1] + w[0][3] * FE11_C0_D10_Q64[0][iq][2] + w[0][4] * FE11_C0_D10_Q64[0][iq][3] + w[0][5] * FE11_C0_D10_Q64[0][iq][4] + w[0][6] * FE11_C0_D10_Q64[0][iq][5] + w[0][7] * FE11_C0_D10_Q64[0][iq][6] + w[0][8] * FE11_C0_D10_Q64[0][iq][7] + w[0][9] * FE11_C0_D10_Q64[0][iq][8] + w[0][10] * FE11_C0_D10_Q64[0][iq][9] + w[0][11] * FE11_C0_D10_Q64[0][iq][10] + w[0][12] * FE11_C0_D10_Q64[0][iq][11] + w[0][13] * FE11_C0_D10_Q64[0][iq][12] + w[0][14] * FE11_C0_D10_Q64[0][iq][13];
        const double w1_d1 = w[1][0] * FE11_C0_D01_Q64[0][iq][0] + w[1][2] * FE11_C0_D01_Q64[0][iq][1] + w[1][3] * FE11_C0_D01_Q64[0][iq][2] + w[1][4] * FE11_C0_D01_Q64[0][iq][3] + w[1][5] * FE11_C0_D01_Q64[0][iq][4] + w[1][6] * FE11_C0_D01_Q64[0][iq][5] + w[1][7] * FE11_C0_D01_Q64[0][iq][6] + w[1][8] * FE11_C0_D01_Q64[0][iq][7] + w[1][9] * FE11_C0_D01_Q64[0][iq][8] + w[1][10] * FE11_C0_D01_Q64[0][iq][9] + w[1][11] * FE11_C0_D01_Q64[0][iq][10] + w[1][12] * FE11_C0_D01_Q64[0][iq][11] + w[1][13] * FE11_C0_D01_Q64[0][iq][12] + w[1][14] * FE11_C0_D01_Q64[0][iq][13];
        const double w1_d0 = w[1][0] * FE11_C0_D10_Q64[0][iq][0] + w[1][1] * FE11_C0_D10_Q64[0][iq][1] + w[1][3] * FE11_C0_D10_Q64[0][iq][2] + w[1][4] * FE11_C0_D10_Q64[0][iq][3] + w[1][5] * FE11_C0_D10_Q64[0][iq][4] + w[1][6] * FE11_C0_D10_Q64[0][iq][5] + w[1][7] * FE11_C0_D10_Q64[0][iq][6] + w[1][8] * FE11_C0_D10_Q64[0][iq][7] + w[1][9] * FE11_C0_D10_Q64[0][iq][8] + w[1][10] * FE11_C0_D10_Q64[0][iq][9] + w[1][11] * FE11_C0_D10_Q64[0][iq][10] + w[1][12] * FE11_C0_D10_Q64[0][iq][11] + w[1][13] * FE11_C0_D10_Q64[0][iq][12] + w[1][14] * FE11_C0_D10_Q64[0][iq][13];
        double w1 = 0.0;
        for (int ic = 0; ic < 15; ++ic)
            w1 += w[1][ic] * FE11_C0_Q64[0][iq][ic];
        double w0 = 0.0;
        for (int ic = 0; ic < 15; ++ic)
            w0 += w[0][ic] * FE11_C0_Q64[0][iq][ic];
        alignas(32) double sv64[22];
        sv64[0] = w0_d1 * sp[3];
        sv64[1] = w0_d0 * sp[4];
        sv64[2] = sv64[0] + sv64[1];
        sv64[3] = w1_d1 * sp[3];
        sv64[4] = w1_d0 * sp[4];
        sv64[5] = sv64[3] + sv64[4];
        sv64[6] = sv64[2] + -1 * sv64[5];
        sv64[7] = sv64[6] * sv64[6];
        sv64[8] = w0_d0 * sp[5];
        sv64[9] = w0_d1 * sp[6];
        sv64[10] = sv64[8] + sv64[9];
        sv64[11] = w1_d0 * sp[5];
        sv64[12] = w1_d1 * sp[6];
        sv64[13] = sv64[11] + sv64[12];
        sv64[14] = sv64[10] + -1 * sv64[13];
        sv64[15] = sv64[14] * sv64[14];
        sv64[16] = sv64[7] + sv64[15];
        sv64[17] = -1 * w1 + w0;
        sv64[18] = sv64[17] * sv64[17];
        sv64[19] = sv64[16] + sv64[18];
        sv64[20] = std::sqrt(sv64[19]);
        sv64[21] = sp[7] * sv64[20];
        const double fw0 = sv64[21] * weights64[iq];
        for (int i = 0; i < 15; ++i)
            BF0[i] += fw0 * FE11_C0_Q64[0][iq][i];
    }
    std::fill(A, A + 15, 0.0);
    for (int i = 0; i < 15; ++i)
        A[i] += BF0[i];
  }

};


class converge_form_0: public ufc::form
{
public:

  converge_form_0() : ufc::form()
  {
    // Do nothing
  }

  ~converge_form_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "bb2b0102c1fb551018281be61b83dfd73d474889234ed8f9b0c73f06b57fd7b2bcabd8c7491374947099fb10c19531256b11f94aa542cbef7c715951b7c38db2";
  }

  std::size_t rank() const final override
  {
    return 2;
  }

  std::size_t num_coefficients() const final override
  {
    return 0;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new converge_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new converge_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new converge_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new converge_finite_element_2();
    case 1:
        return new converge_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new converge_dofmap_2();
    case 1:
        return new converge_dofmap_2();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new converge_cell_integral_0_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};


class converge_form_1: public ufc::form
{
public:

  converge_form_1() : ufc::form()
  {
    // Do nothing
  }

  ~converge_form_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "dce2e34c087fc518a8d6adea483ff7b658f84b380437fc3d84a3b23f27030525eb9c656aa9cb697739e24335bbce88dcde3f05480fd631a473fb3e2614830cdc";
  }

  std::size_t rank() const final override
  {
    return 1;
  }

  std::size_t num_coefficients() const final override
  {
    return 2;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new converge_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new converge_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new converge_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new converge_finite_element_2();
    case 1:
        return new converge_finite_element_2();
    case 2:
        return new converge_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new converge_dofmap_2();
    case 1:
        return new converge_dofmap_2();
    case 2:
        return new converge_dofmap_2();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new converge_cell_integral_1_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/mesh/Mesh.h>
#include <dolfin/mesh/MultiMesh.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/fem/MultiMeshForm.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/MultiMeshFunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/function/MultiMeshCoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>
#include <dolfin/la/GenericVector.h>

namespace converge
{

class CoefficientSpace_u1: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_u1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_u1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_u2: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_u2(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_u2(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_a_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_a_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_a_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_a_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_a_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_a_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

class Form_a_MultiMeshFunctionSpace_1: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_a_MultiMeshFunctionSpace_1(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_a_FunctionSpace_1(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

class Form_a: public dolfin::Form
{
public:

  // Constructor
  Form_a(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::make_shared<const converge_form_0>();
  }

  // Destructor
  ~Form_a()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return "unnamed";
  }

  // Typedefs
  typedef Form_a_FunctionSpace_0 TestSpace;
  typedef Form_a_FunctionSpace_1 TrialSpace;
  typedef Form_a_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_a_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;

  // Coefficients
};

class MultiMeshForm_a: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_a(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V1, V0)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_a(V1->part(part), V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Destructor
  ~MultiMeshForm_a()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return "unnamed";
  }

  // Typedefs
  typedef Form_a_FunctionSpace_0 TestSpace;
  typedef Form_a_FunctionSpace_1 TrialSpace;
  typedef Form_a_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_a_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;

  // Coefficients
};

class Form_L_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_L_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_L_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<converge_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<converge_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_L_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_L_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_L_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_u1 Form_L_FunctionSpace_1;

typedef CoefficientSpace_u2 Form_L_FunctionSpace_2;

class Form_L: public dolfin::Form
{
public:

  // Constructor
  Form_L(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 2), u1(*this, 0), u2(*this, 1)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::make_shared<const converge_form_1>();
  }

  // Constructor
  Form_L(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> u1, std::shared_ptr<const dolfin::GenericFunction> u2):
    dolfin::Form(1, 2), u1(*this, 0), u2(*this, 1)
  {
    _function_spaces[0] = V0;

    this->u1 = u1;
    this->u2 = u2;

    _ufc_form = std::make_shared<const converge_form_1>();
  }

  // Destructor
  ~Form_L()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "u1")
      return 0;
    else if (name == "u2")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "u1";
    case 1:
      return "u2";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_L_FunctionSpace_0 TestSpace;
  typedef Form_L_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_L_FunctionSpace_1 CoefficientSpace_u1;
  typedef Form_L_FunctionSpace_2 CoefficientSpace_u2;

  // Coefficients
  dolfin::CoefficientAssigner u1;
  dolfin::CoefficientAssigner u2;
};

class MultiMeshForm_L: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_L(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V0), u1(*this, 0), u2(*this, 1)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_L(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_L(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> u1, std::shared_ptr<const dolfin::GenericFunction> u2):
    dolfin::MultiMeshForm(V0), u1(*this, 0), u2(*this, 1)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_L(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients
    this->u1 = u1;
    this->u2 = u2;

  }

  // Destructor
  ~MultiMeshForm_L()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "u1")
      return 0;
    else if (name == "u2")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "u1";
    case 1:
      return "u2";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_L_FunctionSpace_0 TestSpace;
  typedef Form_L_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_L_FunctionSpace_1 CoefficientSpace_u1;
  typedef Form_L_FunctionSpace_2 CoefficientSpace_u2;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner u1;
  dolfin::MultiMeshCoefficientAssigner u2;
};

// Class typedefs
typedef Form_a BilinearForm;
typedef MultiMeshForm_a MultiMeshBilinearForm;
typedef Form_a JacobianForm;
typedef MultiMeshForm_a MultiMeshJacobianForm;
typedef Form_L LinearForm;
typedef MultiMeshForm_L MultiMeshLinearForm;
typedef Form_L ResidualForm;
typedef MultiMeshForm_L MultiMeshResidualForm;
typedef Form_a::TestSpace FunctionSpace;
typedef Form_a::MultiMeshTestSpace MultiMeshFunctionSpace;

}

#endif
